{"meta":{"title":"K4oer'Blog","subtitle":"","description":"Time is water","author":"K4oer","url":"http://K4oer.gitee.io","root":"/"},"pages":[{"title":"","date":"2021-05-06T13:10:18.964Z","updated":"2021-05-06T13:10:07.175Z","comments":true,"path":"links/link.css","permalink":"http://k4oer.gitee.io/links/link.css","excerpt":"","text":".allLinks { display: -webkit-flex; /* Safari */ display: flex; flex-wrap: wrap; justify-content: center; } .allLinks li { list-style: none; display: inline-flex; border-radius: 1rem; width: 20rem; height: 8rem; margin-top: 3rem; margin-right:2rem; overflow: hidden; /*超出边界部分隐藏*/ background-color: #403e3e; } .allLinks li img { width:6rem; height:6rem; border-radius: 50%; margin: 1rem; } .allLinks li a { width: 12rem; padding-top: 10%; text-align: center; cursor: pointer; text-decoration: none; font-size: 1.7rem; font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", 微软雅黑, Arial, sans-serif; color:#bbb; word-wrap: break-word; /*文字换行*/ }"},{"title":"categories","date":"2021-05-04T16:15:41.000Z","updated":"2021-05-04T16:15:41.988Z","comments":true,"path":"categories/index.html","permalink":"http://k4oer.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-06T13:12:31.302Z","updated":"2021-05-06T13:12:12.058Z","comments":true,"path":"links/index.html","permalink":"http://k4oer.gitee.io/links/index.html","excerpt":"","text":"K4oer'CSDN"},{"title":"分类一","date":"2021-05-06T10:16:22.000Z","updated":"2021-05-06T11:56:38.597Z","comments":false,"path":"categories/index-1.html","permalink":"http://k4oer.gitee.io/categories/index-1.html","excerpt":"","text":""},{"title":"","date":"2021-05-06T13:14:35.158Z","updated":"2021-05-06T13:14:35.158Z","comments":true,"path":"tags/index.html","permalink":"http://k4oer.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-06T10:17:28.000Z","updated":"2021-05-06T10:17:28.490Z","comments":true,"path":"friends/index.html","permalink":"http://k4oer.gitee.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"DES算法逆向分析","slug":"DES算法逆向分析","date":"2021-05-04T16:00:00.000Z","updated":"2021-05-05T13:09:25.576Z","comments":true,"path":"undefined/DES算法逆向分析.html","link":"","permalink":"http://k4oer.gitee.io/undefined/DES%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html","excerpt":"","text":"DES算法逆向分析前言：了解DES算法的基本流程： 一. 用IDA打开，得到汇编代码 二. 逐层分析1. 整体初始化 rep stosd之前为栈的初始化，为程序分配栈空间 123456mov eax, ds:dword_428458 mov dword ptr [ebp+var_C], eax mov ecx, ds:dword_42845Cmov dword ptr [ebp+var_C+4], ecxmov dl, ds:byte_428460mov [ebp+var_C+8], dl 将dword_428458的值’_3ED’和dword_42845c的值’C1nE’分配到ptr [ebp+var_C+8]数组空间中，并且按照小端存储方式，最终的数组内容为’DE3_En1C’(即为初始密钥) 接下来为调用scanf函数，按照要求‘give me a string to encrypt’ 输入一串字符Str,判断Str长度，如果长度为8则跳转到 short loc_40111D 1234call _strlenadd esp, 4cmp eax, 8jz short loc_40111D 否则执行system(‘pause’)指令,令eax的值为-1，并跳转到loc_4011A6 12345push offset Command ; &quot;pause&quot;call _systemadd esp, 4or eax, 0FFFFFFFFhjmp loc_4011A6 之后进行整个函数栈的销毁 2. 主函数分析 调用了两个函数，首先对call sub_40100F分析，进入函数 12345678910111213141516171819202122232425262728293031323334353637; Attributes: bp-based framesub_401BE0 proc nearvar_EC= byte ptr -0EChvar_AC= dword ptr -0AChSrc= byte ptr -0A8hvar_78= dword ptr -78hvar_5C= dword ptr -5Chvar_40= byte ptr -40harg_0= dword ptr 8push ebpmov ebp, espsub esp, 0EChpush ebxpush esipush edilea edi, [ebp+var_EC]mov ecx, 3Bhmov eax, 0CCCCCCCChrep stosd //函数栈空间的初始化和分配0ECh大小的空间push 8 //将8压入栈lea eax, [ebp+var_40]push eaxmov ecx, [ebp+arg_0]push ecxcall sub_40101E //调用sub_40101E函数add esp, 0Chlea edx, [ebp+var_78]push edxlea eax, [ebp+var_40]push eaxcall sub_401046 //调用sub_401046函数add esp, 8mov [ebp+var_AC], 0jmp short loc_401C3B 接下来对内部调用的两个函数进行分析 进入sub_40101E函数分析： 第一块同样为初始化，第二块开始为两层循环，第一层判断ecx计数器次数是否等于[ebp+args_8]的值也就是之前压入栈的8，如果大于等于则跳转到loc_401426进行pop栈销毁，否则进入下一层循环，对应loc_4013F4处，判断是否循环少于8次，少于进入循环内部 123456789101112131415mov eax, [ebp+arg_0] //将[ebp+arg_0]变量（第一个参数）赋给eaxadd eax, [ebp+var_4] //eax加上第一层循环的循环变量[ebp+var_4]xor ecx, ecx //ecx清零，也就是第二层循环重新开始mov cl, [eax] //eax值赋给cl段mov edx, ecx //上一层的ecx值赋给edxmov ecx, 7 //ecx的值赋为7sub ecx, [ebp+var_8] //ecx(7)减第二层循环变量[ebp+var_8]sar edx, cl //将edx的值算数右移cl位and edx, 1 //将右移后edx值和1进行按位与运算mov eax, [ebp+var_4] //将第一层循环变量值赋给eaxmov ecx, [ebp+var_8] //将第二层循环变量值赋给ecxlea eax, [ecx+eax*8] //8*eax+ecx并装入eaxmov ecx, [ebp+arg_4] //第二个参数赋给ecxmov [ecx+eax], dl //之前算出(右移，与运算）的dx寄存器内（低8位）的值赋给ecx和eax值的和jmp short loc_4013EB //跳转到loc_4013E8 loc_4013E8函数内进行第二层循环变量自增，loc_4013D1函数内为第一层循环变量的自增。 进入sub_401046函数分析： 直接看第二块循环语句，循环38h(56)次，在循环内： 12345678mov ecx, [ebp+var_4] movsx (带符号扩展) edx, ds:byte_4280EC[ecx]mov eax, [ebp+arg_4] add eax, [ebp+var_4] //第二个形参加上循环变量[ebp+var_4]，并存到eaxmov ecx, [ebp+arg_0]mov dl, [ecx+edx-1] mov [eax], dljmp short loc_401A51 实现的功能为：将byte_4280EC[]数组(最大56轮)的值加上函数第一个形参ecx，再减1，将值存到dl寄存器，再将dl的值赋给eax所指向内存单元的字节数，之后循环变量自增。 回到主函数第二块分析：是一个for循环语句，判断循环变量[ebp+var_AC]的值是否等于（10h)16，如果大于等于16则跳转到loc_401CB9,进行函数栈销毁，小于则进入循环 进入循环内部： 12345678910111213141516171819202122232425262728293031323334mov edx, [ebp+var_AC]movsx eax, ds:byte_428154[edx]push eax ; intlea ecx, [ebp+var_78]push ecx ; intlea edx, [ebp+var_78]push edx ; Srccall sub_401014 //对[ebp+var_78]调用sub_401014函数add esp, 0Chmov eax, [ebp+var_AC]movsx ecx, ds:byte_428154[eax]push ecx ; intlea edx, [ebp+var_5C]push edx ; intlea eax, [ebp+var_5C]push eax ; Srccall sub_401014 //第二次调用sub_401014函数,参数为[ebp+var_5C]和byte_428154[eax]add esp, 0Chlea ecx, [ebp+Src]push ecxlea edx, [ebp+var_78]push edxcall sub_40100A //调用sub_40100A，参数为[ebp+var_78]和Srcadd esp, 8push 30h ; &#x27;0&#x27; ; Size //将48压入栈lea eax, [ebp+Src]push eax ; Srcmov ecx, [ebp+var_AC]imul ecx, 30h ; &#x27;0&#x27; add ecx, offset unk_42DC9C //将ecx计数器的值和48相乘再加上地址为unk_42DC9C处的值，结果存到ecxpush ecx ; void *call _memcpy //调用memcpy函数add esp, 0Chjmp loc_401C2C //之后是循环变量自增 对调用的函数依次分析： 进入sub_401014 对第一块，分配64h大小的空间调用memcpy函数，将Src字符串的内容赋给[ebp+var_1c]数组，将变量[ebp+var_24](用v4表示）初始化为0，接下来为while循环，[ebp+var_20]（用v5表示）为循环变量，循环大小为1Ch即28，在while循环内部 123456789mov ecx, [ebp+arg_4] add ecx, [ebp+var_24] //第二个形参和v4相加，存到ecxmov edx, [ebp+var_20] //v5赋给edxmov al, [ebp+edx+var_1C] //在数组内寻找v5指向的字节，存到al寄存器mov [ecx], al //将al寄存器的值赋给ecx指向在内存的字节mov ecx, [ebp+var_24] add ecx, 1 //v4自增mov [ebp+var_24], ecxjmp short loc_401B49 之后是一个for循环 for循环内，判断循环变量[ebp+var_20]是否大于等于第三个形参[ebp+arg_8]，若大于等于则跳出循环（add esp,64h)，否则和while循环内容实现功能相同。 进入sub_40100A函数 是一个for 循环，循环大小为30h（48），循环变量为[ebp+var_4]（用i表示），先初始化为0 12345678mov ecx, [ebp+var_4]movsx edx, ds:byte_428124[ecx] //按i指向的字节数组byte的对应值赋给edxmov eax, [ebp+arg_4] add eax, [ebp+var_4] //i+第二个参数[ebp+arg_4],存到eaxmov ecx, [ebp+arg_0] //第一个形参存到ecxmov dl, [ecx+edx-1] // edx的值和第一个形参指向内存的字节单元值存到dl寄存器mov [eax], dl //dl寄存器的值赋给eax指向内存的字节单元jmp short loc_401AC1 memcpy函数实现将Src字符串的值赋给ecx寄存器内的值，大小为48u 回到主函数: 轮函数sub_401032分析调用的第二个函数call sub_401032： 第一块： 123456789101112131415161718192021222324252627282930313233343536373839push ebpmov ebp, espsub esp, 0E4hpush ebxpush esipush edilea edi, [ebp+var_E4]mov ecx, 39hmov eax, 0CCCCCCCCh rep stosd //初始化push 8lea eax, [ebp+Src]push eaxmov ecx, [ebp+arg_0]push ecx call sub_40101E //调用sub_40101E函数add esp, 0Chlea edx, [ebp+Src]push edx ; intlea eax, [ebp+Src]push eax ; Srccall sub_401028 //调用sub_401028函数add esp, 8push 20h(32) ; &#x27; &#x27; ; Sizelea ecx, [ebp+Src]push ecx ; Srclea edx, [ebp+var_84]push edx ; void *call _memcpy //add esp, 0Chpush 20h (32); &#x27; &#x27; ; Size lea eax, [ebp+var_24]push eax ; Srclea ecx, [ebp+var_A4]push ecx ; void *call _memcpy //调用两次memcpy函数add esp, 0Chmov [ebp+var_4], 0jmp short loc_40124C 对于sub_40101E函数，之前已经分析过，可知其实现功能为： 对于sub_401028函数 在第一块，先调用了mempy函数将Src内容拷贝给了 第二块为一个循环语句，进行40h（64）轮循环，在每轮循环中，将byte_42801C数组对应得值加上[ebp+var_45]指向内存的值，并将值赋给循环变量[ebp+var_4]和[ebp+arg_4]的和（这里的函数功能与之前的类似，简要说明） 接下来调用了两次memcpy函数 之后进行了15轮循环 观察发现，在循环内和循环外，都调用了sub_401005,sub_401023函数，对于 sub_401005函数： 发现依次调用了sub_40104B, sub_401023, sub_40103C，sub_401037函数，并在最后调用了memcpy函数，将Src的值赋值给了[ebp+arg_4] 依次分析： (i) sub_40104B 首先调用了memcpy函数，将Src的值赋给了[ebp+var_30]，看第二块发现是for循环，循环48次，在循环内 1234567mov eax, [ebp+var_34] //循环变量[ebp+var_34]（用i表示）movsx ecx, ds:byte_42809C[eax] //i对应的byte_42809C的值存到ecxmov edx, [ebp+arg_4]add edx, [ebp+var_34] //i与[ebp+arg_4]相加mov al, byte ptr [ebp+ecx+var_34+3] //ecx+3+i对应的字节数组赋给i与[ebp+arg_4]的和mov [edx], aljmp short loc_401693 (ii) sub_401023函数 同样为一个for循环，循环次数为[ebp+arg_8]对应的值（即32次），在循环内部 1234567891011121314mov edx, [ebp+arg_0] add edx, [ebp+var_4] //循环变量与[ebp+arg_0]相加xor eax, eax //eax清零mov al, [edx] //存到almov ecx, [ebp+arg_4] add ecx, [ebp+var_4] //循环变量与[ebp+arg_4]相加xor edx, edx //edx清零mov dl, [ecx] //存到dladd eax, edx //两次结果相加and eax, 1 //和与1按位与mov ecx, [ebp+arg_0]add ecx, [ebp+var_4] mov [ecx], al //和赋给（循环变量和[ebp+var_arg0]的和）jmp short loc_401921 (iii) sub_40103C 第二块：while循环，[ebp+var_4]为循环变量（用i表示），循环8次，在循环内 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mov ecx, [ebp+var_4]imul ecx, 6 //6*imov edx, [ebp+arg_0] xor eax, eax //eax清零mov al, [edx+ecx]shl eax, 1 //左移1位mov ecx, [ebp+var_4]imul ecx, 6 //6*imov edx, [ebp+arg_0] xor ebx, ebx //ebx清零mov bl, [edx+ecx+5] //和+5or eax, ebx //eax和ebx进行或运算and eax, 3 //eax和3按位与mov [ebp+var_C], eaxmov eax, [ebp+var_4]imul eax, 6 mov ecx, [ebp+arg_0]xor edx, edxmov dl, [ecx+eax+1]shl edx, 3 //左移3位mov eax, [ebp+var_4]imul eax, 6mov ecx, [ebp+arg_0]xor ebx, ebx //ebx清零mov bl, [ecx+eax+2]shl ebx, 2or edx, ebxmov eax, [ebp+var_4] imul eax, 6 mov ecx, [ebp+arg_0]xor ebx, ebxmov bl, [ecx+eax+3]shl ebx, 1 //左移1位or edx, ebxmov eax, [ebp+var_4]imul eax, 6mov ecx, [ebp+arg_0]xor ebx, ebxmov bl, [ecx+eax+4]or edx, ebxand edx, 0Fh（15） //与15按位与mov [ebp+var_10], edxmov edx, [ebp+var_4]shl edx, 6mov eax, [ebp+var_C]shl eax, 4mov ecx, [ebp+var_10]add ecx, edxmovsx edx, ds:byte_428164[eax+ecx]and edx, 0Fh（15） 123v3 &#x3D; byte_428164[64 * v5 + 16 * ((*(_BYTE *)(a1 + 6 * v5 + 5) | (unsigned __int8)(2 * *(_BYTE *)(a1 + 6 * v5))) &amp; 3) + ((*(_BYTE *)(a1 + 6 * v5 + 4) | (unsigned __int8)((2 * *(_BYTE *)(a1 + 6 * v5 + 3)) | (4 * *(_BYTE *)(a1 + 6 * v5 + 2)) | (8 * *(_BYTE *)(a1 + 6 * v5 + 1)))) &amp; 15)] &amp; 15; 大致运算如上 12345678910111213141516171819202122232425262728mov [ebp+var_14], dlmovsx eax, [ebp+var_14]sar//右移 eax, 3and eax, 1mov ecx, [ebp+arg_4]add ecx, [ebp+var_8]mov [ecx], almovsx edx, [ebp+var_14]sar edx, 2and edx, 1mov eax, [ebp+arg_4]add eax, [ebp+var_8]mov [eax+1], dlmovsx ecx, [ebp+var_14]sar ecx, 1and ecx, 1mov edx, [ebp+arg_4]add edx, [ebp+var_8]mov [edx+2], clmovsx eax, [ebp+var_14]and eax, 1mov ecx, [ebp+arg_4]add ecx, [ebp+var_8]mov [ecx+3], almov edx, [ebp+var_8]add edx, 4mov [ebp+var_8], edxjmp loc_401718 123456*(_BYTE *)(v4 + a2) = (v3 &gt;&gt; 3) &amp; 1; *(_BYTE *)(v4 + a2 + 1) = (v3 &gt;&gt; 2) &amp; 1; *(_BYTE *)(v4 + a2 + 2) = (v3 &gt;&gt; 1) &amp; 1; *(_BYTE *)(v4 + a2 + 3) = v3 &amp; 1; v4 += 4; result = ++v5; 大致运算如上 (iiii) sub_401037 先调用memcpy函数将Src赋值给[ebp+var_20] 之后进行(20h)32轮循环，实现功能与sub_401014类似，这里不做重复说明 在sub_401032函数末尾 返回了sub_40102D函数 有两层for循环，一层循环次数为[ebp+arg_8]，第二层循环次数为7，第一层循环： 12345678mov edx, [ebp+var_4] //第一层循环变量imov eax, [ebp+arg_0]xor ecx, ecxmov cl, [eax+edx*8] and ecx, 1 //([ebp+arg_0]+8*i)与1相与mov byte ptr [ebp+var_C], cl //结果存到[ebp+avr_C]mov [ebp+var_8], 1 //初始化第二层循环变量[ebp+var_8](用j表示)为1jmp short loc_4014A5 跳转到下一层循环： 12345678910111213141516mov eax, [ebp+var_C]and eax, 0FFh shl eax, 1 //eax左移1位即eax乘2 mov byte ptr [ebp+var_C], almov ecx, [ebp+var_C]and ecx, 0FFhmov edx, [ebp+var_4]mov eax, [ebp+var_8]lea edx, [eax+edx*8] //(a+j+8*i)mov eax, [ebp+arg_0]xor ebx, ebxmov bl, [eax+edx] //结果存到bx寄存器低位and ebx, 1 //add ecx, ebxmov byte ptr [ebp+var_C], cl //cl赋给ptr[ebp+var_C]jmp short loc_40149C 到此sub_401032函数分析完毕，可知该函数为16次轮函数 回到主函数： 第二块开始为for循环，[ebp+var2C]为循环变量，循环8次 12345678mov eax, [ebp+var_2C]xor ecx, ecx //ecx清零mov cl, [ebp+eax+var_28] //[ebp+var_28]和eax的和赋给cl,8位密文mov edx, [ebp+var_2C] xor eax, eax mov al, byte_42AA30[edx] //byte数组（0xef,0x34,0xd4,0xa3,0xc6,0x84,0xe4,0x23）赋给alcmp ecx, eax //判断ecx和eax是否相等jz short loc_401188 若不相等则输出 Wrong! 相等则输出G00d Job!! 综上所述初始密钥为：DE3_En1C 运用des解密算法可知明文为：HarDd3s?","categories":[],"tags":[]}],"categories":[],"tags":[]}