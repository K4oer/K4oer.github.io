{"meta":{"title":"K4oer'Blog","subtitle":"风也温柔","description":"Time is water","author":"K4oer","url":"http://K4oer.gitee.io","root":"/"},"pages":[{"title":"404","date":"2021-05-08T09:40:27.000Z","updated":"2021-05-08T09:45:11.283Z","comments":false,"path":"404/index-1.html","permalink":"http://k4oer.gitee.io/404/index-1.html","excerpt":"","text":""},{"title":"404","date":"2021-05-06T14:02:40.000Z","updated":"2021-05-06T14:02:40.560Z","comments":true,"path":"404/index.html","permalink":"http://k4oer.gitee.io/404/index.html","excerpt":"","text":""},{"title":"分类一","date":"2021-05-06T10:16:22.000Z","updated":"2021-05-08T09:11:41.163Z","comments":false,"path":"categories/index-1.html","permalink":"http://k4oer.gitee.io/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-04T16:15:41.000Z","updated":"2021-05-04T16:15:41.988Z","comments":true,"path":"categories/index.html","permalink":"http://k4oer.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-05-08T09:13:48.000Z","updated":"2021-05-08T09:15:05.754Z","comments":true,"path":"contact/index.html","permalink":"http://k4oer.gitee.io/contact/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-08T09:12:45.000Z","updated":"2021-05-08T09:13:19.094Z","comments":true,"path":"about/index.html","permalink":"http://k4oer.gitee.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-06T14:02:26.000Z","updated":"2021-05-06T14:02:26.841Z","comments":true,"path":"friends/index-1.html","permalink":"http://k4oer.gitee.io/friends/index-1.html","excerpt":"","text":""},{"title":"","date":"2021-05-06T13:12:31.302Z","updated":"2021-05-06T13:12:12.058Z","comments":true,"path":"links/index.html","permalink":"http://k4oer.gitee.io/links/index.html","excerpt":"","text":"K4oer'CSDN"},{"title":"","date":"2021-05-06T13:10:18.964Z","updated":"2021-05-06T13:10:07.175Z","comments":true,"path":"links/link.css","permalink":"http://k4oer.gitee.io/links/link.css","excerpt":"","text":".allLinks { display: -webkit-flex; /* Safari */ display: flex; flex-wrap: wrap; justify-content: center; } .allLinks li { list-style: none; display: inline-flex; border-radius: 1rem; width: 20rem; height: 8rem; margin-top: 3rem; margin-right:2rem; overflow: hidden; /*超出边界部分隐藏*/ background-color: #403e3e; } .allLinks li img { width:6rem; height:6rem; border-radius: 50%; margin: 1rem; } .allLinks li a { width: 12rem; padding-top: 10%; text-align: center; cursor: pointer; text-decoration: none; font-size: 1.7rem; font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", 微软雅黑, Arial, sans-serif; color:#bbb; word-wrap: break-word; /*文字换行*/ }"},{"title":"","date":"2021-05-06T13:14:35.158Z","updated":"2021-05-06T13:14:35.158Z","comments":true,"path":"tags/index.html","permalink":"http://k4oer.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"[现代密码学] Crypto 知识点总结（古典密码&&对称加密&&hash函数）","date":"2021-05-08T11:05:24.607Z","updated":"2021-05-08T11:04:04.486Z","comments":true,"path":"undefined/[现代密码学] Crypto 知识点总结（古典密码&&对称加密&&hash函数）.html","link":"","permalink":"http://k4oer.gitee.io/undefined/[%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6]%20Crypto%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81&&%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&&hash%E5%87%BD%E6%95%B0%EF%BC%89.html","excerpt":"","text":"@TOC 一 . 常见加解密SM1-4国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。 SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。 SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。 SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。 SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。 二. 古典密码代换密码 分类： 移位（凯撒）密码 仿射密码 单表代换 多表代换 置换密码 Hill密码 转轮密码恩格码机 代换密码的唯密文攻击 1.统计攻击 2.重合指数法例题 密码分析可分为那几类，它们的含义是什么？根据密码分析者可能取得的分析资料的不同，密码分析（或称攻击）可分为下列四类：1）唯密文分析（攻击），密码分析者取得一个或多个用同一密钥加密的密文；2）已知明文分析（攻击），除要破译的密文外，密码分析者还取得一些用同一密钥加密的明密文对；3）选择明文分析（攻击），密码分析者可取得他所选择的任何明文所对应的密文（当然不包括他要恢复的明文），这些明密文对和要破译的密文是用同一密钥加密的；4）选择密文分析（攻击），密码分析者可取得他所选择的任何密文所对应的明文（要破译的密文除外），这些密文和明文和要破译的密文是用同一解密密钥解密的，它主要应用于公钥密码体制。 移位密码，仿射密码，单表代换密码都没有破坏明文的频率统计规律，可以直接用统计分析法 字母频率分析法对（单表代换密码）算法最有效例题 三. 对称加密算法12引自合天网安实验室：https:&#x2F;&#x2F;www.hetianlab.com&#x2F;expc.do?ce&#x3D;7bbc91e0-a9b3-4af9-a108-ce94117ee430以及现代密码学（谷利泽版） 分组密码设计思想： 混淆：明文/密钥和密文之间的关系复杂 分组：明文/密钥的每一个比特都影响密文的每一个比特DES算法（数据加密标准）1. Feistel结构明文和密文分组长度为64Bit，密钥长度56bit（密钥空间2^56）算法包括：迭代加密和密钥编排 IP置换（初始置换）根据初始置换表，将明文数据移到该数据所在位置从上表我们可以总结出，初始置换表的规律其实就是（其实不用太在意这个规律）：a. 偶数与奇数分开（1~64），然后分为上下两部分，分布在置换表中，偶数在上，奇数在下。 b. 在偶数与奇数内部，又遵从“从右到左，从上到下，从小到大”的排列。 实际中加密的是二进制数据，为直观展示这里用字母代替置换完至此我们便得到了初始置换之后的数据 Data=“5XPHzrjb7ZRJBtld91TLDvnf=3VNFxph4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” L0 = “5XPHzrjb7ZRJBtld91TLDvnf=3VNFxph” R0 = “4WOGyqia6YQI(i)Askc80SKCume+2UMEwog” 2. 轮函数函数 f主要对数据右半部分R进行操作 a. 先对其进行扩展置换，使其变为48位的数据， b. 然后生成的数据再与子密钥进行异或运算， c. 再以异或运算后的48位数据进行S盒代替，将48位的数据，转换为32位的数据， d. 再进行P盒置换，生成32位的数据 e. 最后将P盒置换生成的数据与本轮运算的L进行异或，生成新的R。 f. 而新的L是直接由本轮的R进行替换 3. 密钥编排算法 子密钥K的生成假设初始64位密钥：“abcdefgh ijklmnop qrstuvwx yzABCDEF GHIJKLMN OPQRSTUV WXYZ0123 456789+=”红色部分为奇偶校验位，不参与加密算法 初始压缩置换后：可以看出压缩置换1的规律： 压缩置换1接下来的是拆分： K0=“4WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ+2UMEwog91TLDvnf80SKCumeBtld” C0=“4WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ” D0=“+2UMEwog91TLDvnf80SKCumeBtld” 拆分之后我们得到C0、D0，再然后就是循环左移，求出C1、D1： 根据”轮数和左移位数”的对应表，第一轮得到 123C1&#x3D;“WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ4”D1&#x3D;“2UMEwog91TLDvnf80SKCumeBtld+” 如上，左移的同时还要保持位数不变，所以移动的数据又补充到后面。 C1D1= “WOGyqia5XPHzrjb6YQI(i)Askc7ZRJ42UMEwog91TLDvnf80SKCumeBtld+” 压缩置换2 得到子密钥K1K1=“jYH7WqG4bisPcI(i)zyR56aJArOvBM1KdUDe0wC8uL+otSnm92E” 扩展置换E将数据R（32位），按照每4位一组，拆分成8个组，如图，左右黑色的两列是扩展时添加的数据，中间的就是分组后的数据R，表中的数字代表数据R中的位置。分成8组织后，遵循这样的一个规则：每一组的头部添加本组数据上一组的尾部，每一组的尾部添加本组数据下一组的头部。即第一组数据，前面添加的是最后一组的最后一位数据，后面添加的是第二组的第一位数据…以此类推因此，对R0进行扩展置换R0=“4WOGyqia6YQI(i)Askc80SKCume+2UMEwog”之后我们便得到了扩展到48位的R0： R0=“g4WOGYGYqia6a6YQI(i)AI(i)Askc8c80SKCKCume+e+2UMEMEwog4” 扩展置换E结束之后，我们要进行的就是K1与R0的异或运算 S盒代替S盒代替的作用，就是将我们上一步，R0与K1异或后得到的48位数据压缩为32位数据。 我们前面扩展置换后得到的R0是48位的数据，我们的S盒有8个，那么我们就需要将得到的R0平均分为8组，每组对应一个S盒。每一组的数据长度为6位，假设第一组的二进制数据为：“100110”那么，我们取第一位与最后一位，组成行数：“10”=2取中间四位，组成列数：“0011”=3那么，在对应的S1盒中，取2行3列的数据（第3行第4列）：8，转换为2进制：“1000”那么就将这个得到的4位二进制数据，代替原来第一组的6位数据，这样一来，等8个S盒全部代替完毕，我们就得到32位的数据。 P盒置换至此我们便得到了f(R0,K1),只要再与L0进行异或运算，就得到了第一轮运算最终的R1，然后再将R0的值赋给L1，就完成了第一轮的运算，得到了L1,R1。 4. 末置换 经过16次的运算，我们在函数f的最后，会得到“L16、R16”，这正是我们需要的，然后将L16与R16合并，但是与之前的步骤中的合并不同，此次合并需要先交换二者的位置，也就是应该是R16 L16。 5. 安全增强（1）穷举搜索攻击目标：给定输入输出对 (m i , c i = E(k, m i )) i=1,..,3 ，寻找密钥 k.（2）3DES 1234令 E : K × M -&gt; M 是一个分组密码定义 3E: K^3 × M -&gt;M 为 3E ( (k 1 ,k 2 ,k 3 ), m ) &#x3D;E(k 3 ,E (k 2 , E(k 1 , m)))密钥长度 &#x3D; 3 × 56 &#x3D; 168 bits ( 穷举攻击复杂度≈2 ^118) 参考文章: DES 安全性&amp;3DES , 三重DES原理 AES算法（高级加密标准）对称加密流程分组加密算法：明文（128/256bit)和密文分组（128/192/256bit)可变长度SPN结构：轮函数包括：代换层-置换层-密钥混合层密钥长度：128bit（密钥空间2^128) 10轮 包含4个步骤 字节代替 字节代替（SubBytes）的目的是通过S盒完成一个字节到另外一个字节的映射转换，字节替换为这个密码系统提供了替换性。 行移位行移位（ShiftRows）步骤过程中，每一行都向左循环位移某个偏移量。在AES中（区块大小128位），第一行维持不变，第二行里的每个字节都向左循环移动一格，第三行里的每个字节都向左循环移动二格，第四行里的每个字节都向左循环移动三格。经过行移位之后，矩阵中每一竖列，都是由输入矩阵中的每个不同列中的元素组成。 列混淆这里有一个错误，初始矩阵为，另外列混淆中第二项02·6E=11011100有限域上的字节运算： 轮密钥加 AES的密钥编排算法 密钥扩展：AES的解密变换 分组密码的运行模式1. ECB模式 2. CBC模式 3. CFB模式反馈是指前一个密文分组的值会被送到密码算法的输入端。在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。 明文分组和密文分组之间并没有经过“加密”这一步骤。（加解密过程只调用加密算法这一个过程）在CFB模式中，明文分组和密文分组之间只有一个XOR。j通常为8 参考文章：CFB原理 4. CTR模式（计数器） 例题 1977年1月 DES正式成为美国联邦政府信息处理标准，即FIPS-46标准，1997年撤销，采用AES算法，新算法的分组长度为128比特，支持可变密钥长度128，192，256比特。1999年最终选定Rijndanel算法为新的数据加密标准。 WAPI标准是中国颁布的无线局域网安全国家标准 流密码流密码核心：伪随机数生成器（PRG） LFSR ：线性反馈移位寄存器（为线性函数）密钥流{k}的周期一定要大 例题： RC4算法（序列密码） KSA 123456789//S 表随机化s[i] 数据t[i] 密钥j = 0i = 0for i in range(n): j = (j+s[i]+t[i])%n; s[i],s[j]=s[j],s[i]; PRGA(伪随机数生成算法）12345i = (i+1)%nj = (j+s[i])%nswap(s[i],s[j])t = (s[i]+s[j])%nk = s[t] RC4应用 例题13. 一般的，一个反馈移位寄存器由两部分组成：移位寄存器和反馈函数 四. Hash函数SHA-256算法 例题hash函数的抗二次原像性：对于给定的消息M1，发现另一个消息M2，使得H(M1)=H(M2)在计算上是不可行的。抗碰撞性：找到任意一对不同的M1和M2，使得H（M1）=H（M2）在计算上是不可行的。","categories":[],"tags":[]},{"title":"DES算法逆向分析","slug":"DES算法逆向分析","date":"2021-05-04T16:00:00.000Z","updated":"2021-05-05T13:09:25.576Z","comments":true,"path":"undefined/DES算法逆向分析.html","link":"","permalink":"http://k4oer.gitee.io/undefined/DES%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90.html","excerpt":"","text":"DES算法逆向分析前言：了解DES算法的基本流程： 一. 用IDA打开，得到汇编代码 二. 逐层分析1. 整体初始化 rep stosd之前为栈的初始化，为程序分配栈空间 123456mov eax, ds:dword_428458 mov dword ptr [ebp+var_C], eax mov ecx, ds:dword_42845Cmov dword ptr [ebp+var_C+4], ecxmov dl, ds:byte_428460mov [ebp+var_C+8], dl 将dword_428458的值’_3ED’和dword_42845c的值’C1nE’分配到ptr [ebp+var_C+8]数组空间中，并且按照小端存储方式，最终的数组内容为’DE3_En1C’(即为初始密钥) 接下来为调用scanf函数，按照要求‘give me a string to encrypt’ 输入一串字符Str,判断Str长度，如果长度为8则跳转到 short loc_40111D 1234call _strlenadd esp, 4cmp eax, 8jz short loc_40111D 否则执行system(‘pause’)指令,令eax的值为-1，并跳转到loc_4011A6 12345push offset Command ; &quot;pause&quot;call _systemadd esp, 4or eax, 0FFFFFFFFhjmp loc_4011A6 之后进行整个函数栈的销毁 2. 主函数分析 调用了两个函数，首先对call sub_40100F分析，进入函数 12345678910111213141516171819202122232425262728293031323334353637; Attributes: bp-based framesub_401BE0 proc nearvar_EC= byte ptr -0EChvar_AC= dword ptr -0AChSrc= byte ptr -0A8hvar_78= dword ptr -78hvar_5C= dword ptr -5Chvar_40= byte ptr -40harg_0= dword ptr 8push ebpmov ebp, espsub esp, 0EChpush ebxpush esipush edilea edi, [ebp+var_EC]mov ecx, 3Bhmov eax, 0CCCCCCCChrep stosd //函数栈空间的初始化和分配0ECh大小的空间push 8 //将8压入栈lea eax, [ebp+var_40]push eaxmov ecx, [ebp+arg_0]push ecxcall sub_40101E //调用sub_40101E函数add esp, 0Chlea edx, [ebp+var_78]push edxlea eax, [ebp+var_40]push eaxcall sub_401046 //调用sub_401046函数add esp, 8mov [ebp+var_AC], 0jmp short loc_401C3B 接下来对内部调用的两个函数进行分析 进入sub_40101E函数分析： 第一块同样为初始化，第二块开始为两层循环，第一层判断ecx计数器次数是否等于[ebp+args_8]的值也就是之前压入栈的8，如果大于等于则跳转到loc_401426进行pop栈销毁，否则进入下一层循环，对应loc_4013F4处，判断是否循环少于8次，少于进入循环内部 123456789101112131415mov eax, [ebp+arg_0] //将[ebp+arg_0]变量（第一个参数）赋给eaxadd eax, [ebp+var_4] //eax加上第一层循环的循环变量[ebp+var_4]xor ecx, ecx //ecx清零，也就是第二层循环重新开始mov cl, [eax] //eax值赋给cl段mov edx, ecx //上一层的ecx值赋给edxmov ecx, 7 //ecx的值赋为7sub ecx, [ebp+var_8] //ecx(7)减第二层循环变量[ebp+var_8]sar edx, cl //将edx的值算数右移cl位and edx, 1 //将右移后edx值和1进行按位与运算mov eax, [ebp+var_4] //将第一层循环变量值赋给eaxmov ecx, [ebp+var_8] //将第二层循环变量值赋给ecxlea eax, [ecx+eax*8] //8*eax+ecx并装入eaxmov ecx, [ebp+arg_4] //第二个参数赋给ecxmov [ecx+eax], dl //之前算出(右移，与运算）的dx寄存器内（低8位）的值赋给ecx和eax值的和jmp short loc_4013EB //跳转到loc_4013E8 loc_4013E8函数内进行第二层循环变量自增，loc_4013D1函数内为第一层循环变量的自增。 进入sub_401046函数分析： 直接看第二块循环语句，循环38h(56)次，在循环内： 12345678mov ecx, [ebp+var_4] movsx (带符号扩展) edx, ds:byte_4280EC[ecx]mov eax, [ebp+arg_4] add eax, [ebp+var_4] //第二个形参加上循环变量[ebp+var_4]，并存到eaxmov ecx, [ebp+arg_0]mov dl, [ecx+edx-1] mov [eax], dljmp short loc_401A51 实现的功能为：将byte_4280EC[]数组(最大56轮)的值加上函数第一个形参ecx，再减1，将值存到dl寄存器，再将dl的值赋给eax所指向内存单元的字节数，之后循环变量自增。 回到主函数第二块分析：是一个for循环语句，判断循环变量[ebp+var_AC]的值是否等于（10h)16，如果大于等于16则跳转到loc_401CB9,进行函数栈销毁，小于则进入循环 进入循环内部： 12345678910111213141516171819202122232425262728293031323334mov edx, [ebp+var_AC]movsx eax, ds:byte_428154[edx]push eax ; intlea ecx, [ebp+var_78]push ecx ; intlea edx, [ebp+var_78]push edx ; Srccall sub_401014 //对[ebp+var_78]调用sub_401014函数add esp, 0Chmov eax, [ebp+var_AC]movsx ecx, ds:byte_428154[eax]push ecx ; intlea edx, [ebp+var_5C]push edx ; intlea eax, [ebp+var_5C]push eax ; Srccall sub_401014 //第二次调用sub_401014函数,参数为[ebp+var_5C]和byte_428154[eax]add esp, 0Chlea ecx, [ebp+Src]push ecxlea edx, [ebp+var_78]push edxcall sub_40100A //调用sub_40100A，参数为[ebp+var_78]和Srcadd esp, 8push 30h ; &#x27;0&#x27; ; Size //将48压入栈lea eax, [ebp+Src]push eax ; Srcmov ecx, [ebp+var_AC]imul ecx, 30h ; &#x27;0&#x27; add ecx, offset unk_42DC9C //将ecx计数器的值和48相乘再加上地址为unk_42DC9C处的值，结果存到ecxpush ecx ; void *call _memcpy //调用memcpy函数add esp, 0Chjmp loc_401C2C //之后是循环变量自增 对调用的函数依次分析： 进入sub_401014 对第一块，分配64h大小的空间调用memcpy函数，将Src字符串的内容赋给[ebp+var_1c]数组，将变量[ebp+var_24](用v4表示）初始化为0，接下来为while循环，[ebp+var_20]（用v5表示）为循环变量，循环大小为1Ch即28，在while循环内部 123456789mov ecx, [ebp+arg_4] add ecx, [ebp+var_24] //第二个形参和v4相加，存到ecxmov edx, [ebp+var_20] //v5赋给edxmov al, [ebp+edx+var_1C] //在数组内寻找v5指向的字节，存到al寄存器mov [ecx], al //将al寄存器的值赋给ecx指向在内存的字节mov ecx, [ebp+var_24] add ecx, 1 //v4自增mov [ebp+var_24], ecxjmp short loc_401B49 之后是一个for循环 for循环内，判断循环变量[ebp+var_20]是否大于等于第三个形参[ebp+arg_8]，若大于等于则跳出循环（add esp,64h)，否则和while循环内容实现功能相同。 进入sub_40100A函数 是一个for 循环，循环大小为30h（48），循环变量为[ebp+var_4]（用i表示），先初始化为0 12345678mov ecx, [ebp+var_4]movsx edx, ds:byte_428124[ecx] //按i指向的字节数组byte的对应值赋给edxmov eax, [ebp+arg_4] add eax, [ebp+var_4] //i+第二个参数[ebp+arg_4],存到eaxmov ecx, [ebp+arg_0] //第一个形参存到ecxmov dl, [ecx+edx-1] // edx的值和第一个形参指向内存的字节单元值存到dl寄存器mov [eax], dl //dl寄存器的值赋给eax指向内存的字节单元jmp short loc_401AC1 memcpy函数实现将Src字符串的值赋给ecx寄存器内的值，大小为48u 回到主函数: 轮函数sub_401032分析调用的第二个函数call sub_401032： 第一块： 123456789101112131415161718192021222324252627282930313233343536373839push ebpmov ebp, espsub esp, 0E4hpush ebxpush esipush edilea edi, [ebp+var_E4]mov ecx, 39hmov eax, 0CCCCCCCCh rep stosd //初始化push 8lea eax, [ebp+Src]push eaxmov ecx, [ebp+arg_0]push ecx call sub_40101E //调用sub_40101E函数add esp, 0Chlea edx, [ebp+Src]push edx ; intlea eax, [ebp+Src]push eax ; Srccall sub_401028 //调用sub_401028函数add esp, 8push 20h(32) ; &#x27; &#x27; ; Sizelea ecx, [ebp+Src]push ecx ; Srclea edx, [ebp+var_84]push edx ; void *call _memcpy //add esp, 0Chpush 20h (32); &#x27; &#x27; ; Size lea eax, [ebp+var_24]push eax ; Srclea ecx, [ebp+var_A4]push ecx ; void *call _memcpy //调用两次memcpy函数add esp, 0Chmov [ebp+var_4], 0jmp short loc_40124C 对于sub_40101E函数，之前已经分析过，可知其实现功能为： 对于sub_401028函数 在第一块，先调用了mempy函数将Src内容拷贝给了 第二块为一个循环语句，进行40h（64）轮循环，在每轮循环中，将byte_42801C数组对应得值加上[ebp+var_45]指向内存的值，并将值赋给循环变量[ebp+var_4]和[ebp+arg_4]的和（这里的函数功能与之前的类似，简要说明） 接下来调用了两次memcpy函数 之后进行了15轮循环 观察发现，在循环内和循环外，都调用了sub_401005,sub_401023函数，对于 sub_401005函数： 发现依次调用了sub_40104B, sub_401023, sub_40103C，sub_401037函数，并在最后调用了memcpy函数，将Src的值赋值给了[ebp+arg_4] 依次分析： (i) sub_40104B 首先调用了memcpy函数，将Src的值赋给了[ebp+var_30]，看第二块发现是for循环，循环48次，在循环内 1234567mov eax, [ebp+var_34] //循环变量[ebp+var_34]（用i表示）movsx ecx, ds:byte_42809C[eax] //i对应的byte_42809C的值存到ecxmov edx, [ebp+arg_4]add edx, [ebp+var_34] //i与[ebp+arg_4]相加mov al, byte ptr [ebp+ecx+var_34+3] //ecx+3+i对应的字节数组赋给i与[ebp+arg_4]的和mov [edx], aljmp short loc_401693 (ii) sub_401023函数 同样为一个for循环，循环次数为[ebp+arg_8]对应的值（即32次），在循环内部 1234567891011121314mov edx, [ebp+arg_0] add edx, [ebp+var_4] //循环变量与[ebp+arg_0]相加xor eax, eax //eax清零mov al, [edx] //存到almov ecx, [ebp+arg_4] add ecx, [ebp+var_4] //循环变量与[ebp+arg_4]相加xor edx, edx //edx清零mov dl, [ecx] //存到dladd eax, edx //两次结果相加and eax, 1 //和与1按位与mov ecx, [ebp+arg_0]add ecx, [ebp+var_4] mov [ecx], al //和赋给（循环变量和[ebp+var_arg0]的和）jmp short loc_401921 (iii) sub_40103C 第二块：while循环，[ebp+var_4]为循环变量（用i表示），循环8次，在循环内 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mov ecx, [ebp+var_4]imul ecx, 6 //6*imov edx, [ebp+arg_0] xor eax, eax //eax清零mov al, [edx+ecx]shl eax, 1 //左移1位mov ecx, [ebp+var_4]imul ecx, 6 //6*imov edx, [ebp+arg_0] xor ebx, ebx //ebx清零mov bl, [edx+ecx+5] //和+5or eax, ebx //eax和ebx进行或运算and eax, 3 //eax和3按位与mov [ebp+var_C], eaxmov eax, [ebp+var_4]imul eax, 6 mov ecx, [ebp+arg_0]xor edx, edxmov dl, [ecx+eax+1]shl edx, 3 //左移3位mov eax, [ebp+var_4]imul eax, 6mov ecx, [ebp+arg_0]xor ebx, ebx //ebx清零mov bl, [ecx+eax+2]shl ebx, 2or edx, ebxmov eax, [ebp+var_4] imul eax, 6 mov ecx, [ebp+arg_0]xor ebx, ebxmov bl, [ecx+eax+3]shl ebx, 1 //左移1位or edx, ebxmov eax, [ebp+var_4]imul eax, 6mov ecx, [ebp+arg_0]xor ebx, ebxmov bl, [ecx+eax+4]or edx, ebxand edx, 0Fh（15） //与15按位与mov [ebp+var_10], edxmov edx, [ebp+var_4]shl edx, 6mov eax, [ebp+var_C]shl eax, 4mov ecx, [ebp+var_10]add ecx, edxmovsx edx, ds:byte_428164[eax+ecx]and edx, 0Fh（15） 123v3 &#x3D; byte_428164[64 * v5 + 16 * ((*(_BYTE *)(a1 + 6 * v5 + 5) | (unsigned __int8)(2 * *(_BYTE *)(a1 + 6 * v5))) &amp; 3) + ((*(_BYTE *)(a1 + 6 * v5 + 4) | (unsigned __int8)((2 * *(_BYTE *)(a1 + 6 * v5 + 3)) | (4 * *(_BYTE *)(a1 + 6 * v5 + 2)) | (8 * *(_BYTE *)(a1 + 6 * v5 + 1)))) &amp; 15)] &amp; 15; 大致运算如上 12345678910111213141516171819202122232425262728mov [ebp+var_14], dlmovsx eax, [ebp+var_14]sar//右移 eax, 3and eax, 1mov ecx, [ebp+arg_4]add ecx, [ebp+var_8]mov [ecx], almovsx edx, [ebp+var_14]sar edx, 2and edx, 1mov eax, [ebp+arg_4]add eax, [ebp+var_8]mov [eax+1], dlmovsx ecx, [ebp+var_14]sar ecx, 1and ecx, 1mov edx, [ebp+arg_4]add edx, [ebp+var_8]mov [edx+2], clmovsx eax, [ebp+var_14]and eax, 1mov ecx, [ebp+arg_4]add ecx, [ebp+var_8]mov [ecx+3], almov edx, [ebp+var_8]add edx, 4mov [ebp+var_8], edxjmp loc_401718 123456*(_BYTE *)(v4 + a2) = (v3 &gt;&gt; 3) &amp; 1; *(_BYTE *)(v4 + a2 + 1) = (v3 &gt;&gt; 2) &amp; 1; *(_BYTE *)(v4 + a2 + 2) = (v3 &gt;&gt; 1) &amp; 1; *(_BYTE *)(v4 + a2 + 3) = v3 &amp; 1; v4 += 4; result = ++v5; 大致运算如上 (iiii) sub_401037 先调用memcpy函数将Src赋值给[ebp+var_20] 之后进行(20h)32轮循环，实现功能与sub_401014类似，这里不做重复说明 在sub_401032函数末尾 返回了sub_40102D函数 有两层for循环，一层循环次数为[ebp+arg_8]，第二层循环次数为7，第一层循环： 12345678mov edx, [ebp+var_4] //第一层循环变量imov eax, [ebp+arg_0]xor ecx, ecxmov cl, [eax+edx*8] and ecx, 1 //([ebp+arg_0]+8*i)与1相与mov byte ptr [ebp+var_C], cl //结果存到[ebp+avr_C]mov [ebp+var_8], 1 //初始化第二层循环变量[ebp+var_8](用j表示)为1jmp short loc_4014A5 跳转到下一层循环： 12345678910111213141516mov eax, [ebp+var_C]and eax, 0FFh shl eax, 1 //eax左移1位即eax乘2 mov byte ptr [ebp+var_C], almov ecx, [ebp+var_C]and ecx, 0FFhmov edx, [ebp+var_4]mov eax, [ebp+var_8]lea edx, [eax+edx*8] //(a+j+8*i)mov eax, [ebp+arg_0]xor ebx, ebxmov bl, [eax+edx] //结果存到bx寄存器低位and ebx, 1 //add ecx, ebxmov byte ptr [ebp+var_C], cl //cl赋给ptr[ebp+var_C]jmp short loc_40149C 到此sub_401032函数分析完毕，可知该函数为16次轮函数 回到主函数： 第二块开始为for循环，[ebp+var2C]为循环变量，循环8次 12345678mov eax, [ebp+var_2C]xor ecx, ecx //ecx清零mov cl, [ebp+eax+var_28] //[ebp+var_28]和eax的和赋给cl,8位密文mov edx, [ebp+var_2C] xor eax, eax mov al, byte_42AA30[edx] //byte数组（0xef,0x34,0xd4,0xa3,0xc6,0x84,0xe4,0x23）赋给alcmp ecx, eax //判断ecx和eax是否相等jz short loc_401188 若不相等则输出 Wrong! 相等则输出G00d Job!! 综上所述初始密钥为：DE3_En1C 运用des解密算法可知明文为：HarDd3s?","categories":[],"tags":[]}],"categories":[],"tags":[]}